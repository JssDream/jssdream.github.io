<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Guava RateLimiter</title>
      <link href="//articles/2022/06/22/1655886812960.html"/>
      <url>//articles/2022/06/22/1655886812960.html</url>
      
        <content type="html"><![CDATA[<p>Guava 是 Google 开源的 Java 类库，提供了一个工具类 <strong>RateLimiter</strong> 。我们先来看看 <strong>RateLimiter</strong> 的使用，让你对限流有个感官的印象。假设我们有一个线程池，它每秒只能处理两个任务，如果提交的任务过快，可能导致系统不稳定，这个时候就需要用到限流。</p><p>在下面的示例代码中，我们创建了一个流速为 2 个请求 &#x2F; 秒的限流器，这里的流速该怎么理解呢？直观地看，2 个请求 &#x2F; 秒指的是每秒最多允许 2 个请求通过限流器，其实在 Guava 中，流速还有更深一层的意思：是一种匀速的概念，2 个请求 &#x2F; 秒等价于 1 个请求 &#x2F;500 毫秒。</p><p>在向线程池提交任务之前，调用 <code>acquire()</code> 方法就能起到限流的作用。通过示例代码的执行结果，任务提交到线程池的时间间隔基本上稳定在 500 毫秒。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//限流器流速：2个请求/秒</span><br><span class="line">RateLimiter limiter = </span><br><span class="line">  RateLimiter.create(2.0);</span><br><span class="line">//执行任务的线程池</span><br><span class="line">ExecutorService es = Executors</span><br><span class="line">  .newFixedThreadPool(1);</span><br><span class="line">//记录上一次执行时间</span><br><span class="line">prev = System.nanoTime();</span><br><span class="line">//测试执行20次</span><br><span class="line">for (int i=0; i&lt;20; i++)&#123;</span><br><span class="line">  //限流器限流</span><br><span class="line">  limiter.acquire();</span><br><span class="line">  //提交任务异步执行</span><br><span class="line">  es.execute(()-&gt;&#123;</span><br><span class="line">    long cur=System.nanoTime();</span><br><span class="line">    //打印时间间隔：毫秒</span><br><span class="line">    System.out.println(</span><br><span class="line">      (cur-prev)/1000_000);</span><br><span class="line">    prev = cur;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">...</span><br><span class="line">500</span><br><span class="line">499</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">499</span><br></pre></td></tr></table></figure><h2 id="经典限流算法：令牌桶算法"><a href="#经典限流算法：令牌桶算法" class="headerlink" title="经典限流算法：令牌桶算法"></a>经典限流算法：令牌桶算法</h2><p>Guava 的限流器使用上还是很简单的，那它是如何实现的呢？Guava 采用的是令牌桶算法，其核心是要想通过限流器，必须拿到令牌。也就是说，只要我们能够限制发放令牌的速率，那么就能控制流速了。令牌桶算法的详细描述如下：</p><ol><li>令牌以固定的速率添加到令牌桶中，假设限流的速率是 r&#x2F; 秒，则令牌每 1&#x2F;r 秒会添加一个；</li><li>假设令牌桶的容量是 b ，如果令牌桶已满，则新的令牌会被丢弃；</li><li>请求能够通过限流器的前提是令牌桶中有令牌。</li></ol><p>这个算法中，限流的速率 r 还是比较容易理解的，但令牌桶的容量 b 该怎么理解呢？b 其实是 burst 的简写，意义是<strong>限流器允许的最大突发流量</strong> 。比如 b&#x3D;10，而且令牌桶中的令牌已满，此时限流器允许 10 个请求同时通过限流器，当然只是突发流量而已，这 10 个请求会带走 10 个令牌，所以后续的流量只能按照速率 r 通过限流器。</p><p>令牌桶这个算法，如何用 Java 实现呢？很可能你的直觉会告诉你生产者 - 消费者模式：一个生产者线程定时向阻塞队列中添加令牌，而试图通过限流器的线程则作为消费者线程，只有从阻塞队列中获取到令牌，才允许通过限流器。</p><p>这个算法看上去非常完美，而且实现起来非常简单，如果并发量不大，这个实现并没有什么问题。可实际情况却是使用限流的场景大部分都是高并发场景，而且系统压力已经临近极限了，此时这个实现就有问题了。问题就出在定时器上，在高并发场景下，当系统压力已经临近极限的时候，定时器的精度误差会非常大，同时定时器本身会创建调度线程，也会对系统的性能产生影响。</p><p>那还有什么好的实现方式呢？当然有，Guava 的实现就没有使用定时器，下面我们就来看看它是如何实现的。</p><h2 id="Guava-如何实现令牌桶算法"><a href="#Guava-如何实现令牌桶算法" class="headerlink" title="Guava 如何实现令牌桶算法"></a>Guava 如何实现令牌桶算法</h2><p>Guava 实现令牌桶算法，用了一个很简单的办法，其关键是<strong>记录并动态计算下一令牌发放的时间</strong> 。</p><p>下面我们以一个最简单的场景来介绍该算法的执行过程。假设令牌桶的容量为 b&#x3D;1，限流速率 r &#x3D; 1 个请求 &#x2F; 秒，如下图所示，如果当前令牌桶中没有令牌，下一个令牌的发放时间是在第 3 秒，而在第 2 秒的时候有一个线程 T1 请求令牌，此时该如何处理呢？</p><p><img src="https://b3logfile.com/file/2022/06/solo-fetchupload-16583619993273014618-eb2d73fb.jpeg" alt="图片">线程 T1 请求令牌示意图对于这个请求令牌的线程而言，很显然需要等待 1 秒，因为 1 秒以后（第 3 秒）它就能拿到令牌了。此时需要注意的是，下一个令牌发放的时间也要增加 1 秒，为什么呢？因为第 3 秒发放的令牌已经被线程 T1 预占了。处理之后如下图所示。</p><p><img src="https://b3logfile.com/file/2022/06/solo-fetchupload-1284048123466057244-31137ec7.jpeg" alt="图片">线程 T1 请求结束示意图假设 T1 在预占了第 3 秒的令牌之后，马上又有一个线程 T2 请求令牌，如下图所示。</p><p><img src="https://b3logfile.com/file/2022/06/solo-fetchupload-11278904671753675482-845fd335.jpeg" alt="图片">线程 T2 请求结束示意图上面线程 T1、T2 都是在下一令牌产生时间之前请求令牌，如果线程在下一令牌产生时间之后请求令牌会如何呢？假设在线程 T1 请求令牌之后的 5 秒，也就是第 7 秒，线程 T3 请求令牌，如下图所示。</p><p><img src="https://b3logfile.com/file/2022/06/solo-fetchupload-8337668667657870058-5e9116c2.jpeg" alt="图片">线程 T3 请求令牌示意图由于在第 5 秒已经产生了一个令牌，所以此时线程 T3 可以直接拿到令牌，而无需等待。在第 7 秒，实际上限流器能够产生 3 个令牌，第 5、6、7 秒各产生一个令牌。由于我们假设令牌桶的容量是 1，所以第 6、7 秒产生的令牌就丢弃了，其实等价地你也可以认为是保留的第 7 秒的令牌，丢弃的第 5、6 秒的令牌，也就是说第 7 秒的令牌被线程 T3 占有了，于是下一令牌的的产生时间应该是第 8 秒，如下图所示。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片">线程 T3 请求结束示意图通过上面简要地分析，你会发现，我们<strong>只需要记录一个下一令牌产生的时间，并动态更新它，就能够轻松完成限流功能</strong> 。我们可以将上面的这个算法代码化，示例代码如下所示，依然假设令牌桶的容量是 1。关键是 <code>reserve()&lt;span&gt; &lt;/span&gt;</code>方法，这个方法会为请求令牌的线程预分配令牌，同时返回该线程能够获取令牌的时间。其实现逻辑就是上面提到的：如果线程请求令牌的时间在下一令牌产生时间之后，那么该线程立刻就能够获取令牌；反之，如果请求时间在下一令牌产生时间之前，那么该线程是在下一令牌产生的时间获取令牌。由于此时下一令牌已经被该线程预占，所以下一令牌产生的时间需要加上 1 秒。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class SimpleLimiter &#123;</span><br><span class="line">  //下一令牌产生时间</span><br><span class="line">  long next = System.nanoTime();</span><br><span class="line">  //发放令牌间隔：纳秒</span><br><span class="line">  long interval = 1000_000_000;</span><br><span class="line">  //预占令牌，返回能够获取令牌的时间</span><br><span class="line">  synchronized long reserve(long now)&#123;</span><br><span class="line">    //请求时间在下一令牌产生时间之后</span><br><span class="line">    //重新计算下一令牌产生时间</span><br><span class="line">    if (now &gt; next)&#123;</span><br><span class="line">      //将下一令牌产生时间重置为当前时间</span><br><span class="line">      next = now;</span><br><span class="line">    &#125;</span><br><span class="line">    //能够获取令牌的时间</span><br><span class="line">    long at=next;</span><br><span class="line">    //设置下一令牌产生时间</span><br><span class="line">    next += interval;</span><br><span class="line">    //返回线程需要等待的时间</span><br><span class="line">    return Math.max(at, 0L);</span><br><span class="line">  &#125;</span><br><span class="line">  //申请令牌</span><br><span class="line">  void acquire() &#123;</span><br><span class="line">    //申请令牌时的时间</span><br><span class="line">    long now = System.nanoTime();</span><br><span class="line">    //预占令牌</span><br><span class="line">    long at=reserve(now);</span><br><span class="line">    long waitTime=max(at-now, 0);</span><br><span class="line">    //按照条件等待</span><br><span class="line">    if(waitTime &gt; 0) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        TimeUnit.NANOSECONDS</span><br><span class="line">          .sleep(waitTime);</span><br><span class="line">      &#125;catch(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果令牌桶的容量大于 1，又该如何处理呢？按照令牌桶算法，令牌要首先从令牌桶中出，所以我们需要按需计算令牌桶中的数量，当有线程请求令牌时，先从令牌桶中出。具体的代码实现如下所示。我们增加了一个 <code>resync()&lt;span&gt; &lt;/span&gt;</code>方法，在这个方法中，如果线程请求令牌的时间在下一令牌产生时间之后，会重新计算令牌桶中的令牌数，<strong>新产生的令牌的计算公式是</strong> ：<code>(now-next)/interval</code>，你可对照上面的示意图来理解。reserve() 方法中，则增加了先从令牌桶中出令牌的逻辑，不过需要注意的是，如果令牌是从令牌桶中出的，那么 next 就无需增加一个 interval 了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class SimpleLimiter &#123;</span><br><span class="line">  //当前令牌桶中的令牌数量</span><br><span class="line">  long storedPermits = 0;</span><br><span class="line">  //令牌桶的容量</span><br><span class="line">  long maxPermits = 3;</span><br><span class="line">  //下一令牌产生时间</span><br><span class="line">  long next = System.nanoTime();</span><br><span class="line">  //发放令牌间隔：纳秒</span><br><span class="line">  long interval = 1000_000_000;</span><br><span class="line">  </span><br><span class="line">  //请求时间在下一令牌产生时间之后,则</span><br><span class="line">  // 1.重新计算令牌桶中的令牌数</span><br><span class="line">  // 2.将下一个令牌发放时间重置为当前时间</span><br><span class="line">  void resync(long now) &#123;</span><br><span class="line">    if (now &gt; next) &#123;</span><br><span class="line">      //新产生的令牌数</span><br><span class="line">      long newPermits=(now-next)/interval;</span><br><span class="line">      //新令牌增加到令牌桶</span><br><span class="line">      storedPermits=min(maxPermits, </span><br><span class="line">        storedPermits + newPermits);</span><br><span class="line">      //将下一个令牌发放时间重置为当前时间</span><br><span class="line">      next = now;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //预占令牌，返回能够获取令牌的时间</span><br><span class="line">  synchronized long reserve(long now)&#123;</span><br><span class="line">    resync(now);</span><br><span class="line">    //能够获取令牌的时间</span><br><span class="line">    long at = next;</span><br><span class="line">    //令牌桶中能提供的令牌</span><br><span class="line">    long fb=min(1, storedPermits);</span><br><span class="line">    //令牌净需求：首先减掉令牌桶中的令牌</span><br><span class="line">    long nr = 1 - fb;</span><br><span class="line">    //重新计算下一令牌产生时间</span><br><span class="line">    next = next + nr*interval;</span><br><span class="line">    //重新计算令牌桶中的令牌</span><br><span class="line">    this.storedPermits -= fb;</span><br><span class="line">    return at;</span><br><span class="line">  &#125;</span><br><span class="line">  //申请令牌</span><br><span class="line">  void acquire() &#123;</span><br><span class="line">    //申请令牌时的时间</span><br><span class="line">    long now = System.nanoTime();</span><br><span class="line">    //预占令牌</span><br><span class="line">    long at=reserve(now);</span><br><span class="line">    long waitTime=max(at-now, 0);</span><br><span class="line">    //按照条件等待</span><br><span class="line">    if(waitTime &gt; 0) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        TimeUnit.NANOSECONDS</span><br><span class="line">          .sleep(waitTime);</span><br><span class="line">      &#125;catch(InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经典的限流算法有两个，一个是<strong>令牌桶算法</strong> （Token Bucket），另一个是<strong>漏桶算法</strong> （Leaky Bucket）。令牌桶算法是定时向令牌桶发送令牌，请求能够从令牌桶中拿到令牌，然后才能通过限流器；</p><p>而漏桶算法里，请求就像水一样注入漏桶，漏桶会按照一定的速率自动将水漏掉，只有漏桶里还能注入水的时候，请求才能通过限流器。令牌桶算法和漏桶算法很像一个硬币的正反面，所以你可以参考令牌桶算法的实现来实现漏桶算法。</p><p>上面我们介绍了 Guava 是如何实现令牌桶算法的，我们的示例代码是对 Guava RateLimiter 的简化，Guava RateLimiter 扩展了标准的令牌桶算法，比如还能支持预热功能。对于按需加载的缓存来说，预热后缓存能支持 5 万 TPS 的并发，但是在预热前 5 万 TPS 的并发直接就把缓存击垮了，所以如果需要给该缓存限流，限流器也需要支持预热功能，在初始阶段，限制的流速 r 很小，但是动态增长的。预热功能的实现非常复杂，Guava 构建了一个积分函数来解决这个问题，如果你感兴趣，可以继续深入研究。</p><p>参考：</p><blockquote><p><a href="https://mp.weixin.qq.com/s/SkvrEFCEv3GKmZWRNelSOg"># 高性能限流器 Guava RateLimiter</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Guava </tag>
            
            <tag> 限流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解实现接口数据的脱敏</title>
      <link href="/2022/06/21/202206/%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E7%9A%84%E8%84%B1%E6%95%8F/"/>
      <url>/2022/06/21/202206/%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%95%B0%E6%8D%AE%E7%9A%84%E8%84%B1%E6%95%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="注解实现数据脱敏"><a href="#注解实现数据脱敏" class="headerlink" title="注解实现数据脱敏"></a>注解实现数据脱敏</h2><p>通常接口返回值中的一些敏感数据也是要脱敏的，比如<strong>身份证号</strong> 、<strong>手机号码</strong> 、<strong>地址</strong> …..通常的手段就是用 <code>*</code>隐藏一部分数据，当然也可以根据自己需求定制。</p><p>言归正传，如何优雅的实现呢？有两种实现方案，如下：</p><ul><li>整合Mybatis插件，在查询的时候针对特定的字段进行脱敏</li><li>整合Jackson，在序列化阶段对特定字段进行脱敏</li><li>基于<code>Sharding Sphere</code>实现数据脱敏，查看之前的文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU3MDAzNDg1MA==&mid=2247493021&idx=2&sn=f27a4eeb6dd3eb5b1551eabf6e31739e&chksm=fcf73a50cb80b3465e6f7cf1fd841bfec098fcde47c587a2c35e7793bad3b33ebe8f2433d3ff&token=1439687168&lang=zh_CN&scene=21#wechat_redirect">基于Sharding Sphere实现数据“一键脱敏”</a></li></ul><p>第一种方案网上很多实现方式，下面演示第二种，整合Jackson。</p><h3 id="1-自定义一个Jackson注解"><a href="#1-自定义一个Jackson注解" class="headerlink" title="1. 自定义一个Jackson注解"></a>1. 自定义一个Jackson注解</h3><p>需要自定义一个脱敏注解，一旦有属性被标注，则进行对应得脱敏，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义jackson注解，标注在属性上</span><br><span class="line"> */</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@JacksonAnnotationsInside</span><br><span class="line">@JsonSerialize(using = SensitiveJsonSerializer.class)</span><br><span class="line">public @interface Sensitive &#123;</span><br><span class="line">    //脱敏策略</span><br><span class="line">    SensitiveStrategy strategy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-定制脱敏策略"><a href="#2-定制脱敏策略" class="headerlink" title="2. 定制脱敏策略"></a>2. 定制脱敏策略</h3><p>针对项目需求，定制不同字段的脱敏规则，比如手机号中间几位用 <code>*</code>替代，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 脱敏策略，枚举类，针对不同的数据定制特定的策略</span><br><span class="line"> */</span><br><span class="line">public enum SensitiveStrategy &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 用户名</span><br><span class="line">     */</span><br><span class="line">    USERNAME(s -&gt; s.replaceAll(&quot;(\\S)\\S(\\S*)&quot;, &quot;$1*$2&quot;)),</span><br><span class="line">    /**</span><br><span class="line">     * 身份证</span><br><span class="line">     */</span><br><span class="line">    ID_CARD(s -&gt; s.replaceAll(&quot;(\\d&#123;4&#125;)\\d&#123;10&#125;(\\w&#123;4&#125;)&quot;, &quot;$1****$2&quot;)),</span><br><span class="line">    /**</span><br><span class="line">     * 手机号</span><br><span class="line">     */</span><br><span class="line">    PHONE(s -&gt; s.replaceAll(&quot;(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)&quot;, &quot;$1****$2&quot;)),</span><br><span class="line">    /**</span><br><span class="line">     * 地址</span><br><span class="line">     */</span><br><span class="line">    ADDRESS(s -&gt; s.replaceAll(&quot;(\\S&#123;3&#125;)\\S&#123;2&#125;(\\S*)\\S&#123;2&#125;&quot;, &quot;$1****$2****&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final Function&lt;String, String&gt; desensitizer;</span><br><span class="line"></span><br><span class="line">    SensitiveStrategy(Function&lt;String, String&gt; desensitizer) &#123;</span><br><span class="line">        this.desensitizer = desensitizer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Function&lt;String, String&gt; desensitizer() &#123;</span><br><span class="line">        return desensitizer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上只是提供了部分，具体根据自己项目要求进行配置。</p><h3 id="3-定制JSON序列化实现"><a href="#3-定制JSON序列化实现" class="headerlink" title="3. 定制JSON序列化实现"></a>3. 定制JSON序列化实现</h3><p>下面将是重要实现，对标注注解 <code>@Sensitive</code>的字段进行脱敏，实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 序列化注解自定义实现</span><br><span class="line"> * JsonSerializer&lt;String&gt;：指定String 类型，serialize()方法用于将修改后的数据载入</span><br><span class="line"> */</span><br><span class="line">public class SensitiveJsonSerializer extends JsonSerializer&lt;String&gt; implements ContextualSerializer &#123;</span><br><span class="line">    private SensitiveStrategy strategy;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void serialize(String value, JsonGenerator gen, SerializerProvider serializers) throws IOException &#123;</span><br><span class="line">        gen.writeString(strategy.desensitizer().apply(value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取属性上的注解属性</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public JsonSerializer&lt;?&gt; createContextual(SerializerProvider prov, BeanProperty property) throws JsonMappingException &#123;</span><br><span class="line"></span><br><span class="line">        Sensitive annotation = property.getAnnotation(Sensitive.class);</span><br><span class="line">        if (Objects.nonNull(annotation)&amp;&amp;Objects.equals(String.class, property.getType().getRawClass())) &#123;</span><br><span class="line">            this.strategy = annotation.strategy();</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line">        return prov.findValueSerializer(property.getType(), property);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-定义Person类，对其数据脱敏"><a href="#4-定义Person类，对其数据脱敏" class="headerlink" title="4. 定义Person类，对其数据脱敏"></a>4. 定义Person类，对其数据脱敏</h3><p>使用注解 <code>@Sensitive</code>注解进行数据脱敏，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class Person &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 真实姓名</span><br><span class="line">     */</span><br><span class="line">    @Sensitive(strategy = SensitiveStrategy.USERNAME)</span><br><span class="line">    private String realName;</span><br><span class="line">    /**</span><br><span class="line">     * 地址</span><br><span class="line">     */</span><br><span class="line">    @Sensitive(strategy = SensitiveStrategy.ADDRESS)</span><br><span class="line">    private String address;</span><br><span class="line">    /**</span><br><span class="line">     * 电话号码</span><br><span class="line">     */</span><br><span class="line">    @Sensitive(strategy = SensitiveStrategy.PHONE)</span><br><span class="line">    private String phoneNumber;</span><br><span class="line">    /**</span><br><span class="line">     * 身份证号码</span><br><span class="line">     */</span><br><span class="line">    @Sensitive(strategy = SensitiveStrategy.ID_CARD)</span><br><span class="line">    private String idCard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-模拟接口测试"><a href="#5-模拟接口测试" class="headerlink" title="5. 模拟接口测试"></a>5. 模拟接口测试</h3><p>以上4个步骤完成了数据脱敏的Jackson注解，下面写个controller进行测试，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class TestController &#123;</span><br><span class="line">    @GetMapping(&quot;/test&quot;)</span><br><span class="line">    public Person test()&#123;</span><br><span class="line">        Person user = new Person();</span><br><span class="line">        user.setRealName(&quot;不才陈某&quot;);</span><br><span class="line">        user.setPhoneNumber(&quot;19796328206&quot;);</span><br><span class="line">        user.setAddress(&quot;浙江省杭州市....&quot;);</span><br><span class="line">        user.setIdCard(&quot;4333333333334334333&quot;);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用接口查看数据有没有正常脱敏，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;realName&quot;: &quot;不*陈某&quot;,</span><br><span class="line">    &quot;address&quot;: &quot;浙江省****市..****&quot;,</span><br><span class="line">    &quot;phoneNumber&quot;: &quot;197****8206&quot;,</span><br><span class="line">    &quot;idCard&quot;: &quot;4333****34333&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>数据脱敏有很多种实现方式，关键是哪种更加适合，哪种更加优雅…..</p><p>参考：</p><blockquote><p><a href="https://mp.weixin.qq.com/s/hMoyMeweMQfKLeKo-yCPFA"># 一个注解优雅的实现 接口数据脱敏</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jackjson </tag>
            
            <tag> 注解 </tag>
            
            <tag> 脱敏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试：String 为什么是不可变的？</title>
      <link href="//articles/2022/03/21/1647844375128.html"/>
      <url>//articles/2022/03/21/1647844375128.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>分享一道群友去阿里云面试遇到的 Java 基础面试真题：“<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code> 的区别？<code>String</code> 为什么是不可变的?”。</p></blockquote><p>网站很多文章都把 <code>String</code> 不可变的原因讲错了，建议你重点关注一下。另外，本文还提到了 ：“Java 9 为何要将 String  的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?”</p><p>下面是正文。</p><p><strong>可变性</strong></p><p>简单的来说：<code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，所以<code>String</code> 对象是不可变的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    private final char value[];</span><br><span class="line"> //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>🐛 修正 ：我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li></ol><p>相关阅读：如何理解 String 类型值的不可变？- 知乎提问^[1]^</p><p>补充（来自issue 675^[2]^ ）：在 Java 9 之后，<code>String</code> 、<code>StringBuilder</code> 与 <code>StringBuffer</code> 的实现改用 <code>byte</code> 数组存储字符串。</p><p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p><p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><p>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，<code>byte</code> 和 <code>char</code> 所占用的空间是一样的。</p><p>这是官方的介绍：<a href="https://openjdk.java.net/jeps/254">https://openjdk.java.net/jeps/254</a> 。</p></blockquote><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">abstract class AbstractStringBuilder implements Appendable, CharSequence &#123;</span><br><span class="line">    char[] value;</span><br><span class="line">    public AbstractStringBuilder append(String str) &#123;</span><br><span class="line">        if (str == null)</span><br><span class="line">            return appendNull();</span><br><span class="line">        int len = str.length();</span><br><span class="line">        ensureCapacityInternal(count + len);</span><br><span class="line">        str.getChars(0, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;</span><br><span class="line">   //...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>线程安全性</strong></p><p><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。<code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong></p><p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><strong>对于三者使用的总结：</strong></p><ol><li>操作少量的数据: 适用 <code>String</code></li><li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]如何理解 String 类型值的不可变？- 知乎提问: <em><a href="https://www.zhihu.com/question/20618891/answer/114125846">https://www.zhihu.com/question/20618891/answer/114125846</a></em></p><p>[2]issue 675: <em><a href="https://github.com/Snailclimb/JavaGuide/issues/675">https://github.com/Snailclimb/JavaGuide/issues/675</a></em></p><blockquote><p>原文地址：<a href="https://mp.weixin.qq.com/s/MwaZqbXw9W0S30mXljQhuA">阿里云二面： String 为什么不可变？</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Admin 使用</title>
      <link href="//articles/2022/03/01/1646129161684.html"/>
      <url>//articles/2022/03/01/1646129161684.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Boot-Admin"><a href="#Spring-Boot-Admin" class="headerlink" title="Spring Boot Admin"></a>Spring Boot Admin</h1><blockquote><p>转载于：<a href="https://juejin.cn/post/7052857798530433031">https://juejin.cn/post/7052857798530433031</a></p></blockquote><p>Spring Boot Admin（SBA）是一个开源的社区项目，用于管理和监控 Spring Boot 应用程序。应用程序可以通过 http 的方式，或 Spring Cloud 服务发现机制注册到 SBA 中，然后就可以实现对 Spring Boot 项目的可视化管理和查看了。</p><p>Spring Boot Admin 可以监控 Spring Boot 单机或集群项目，它提供详细的健康 （Health）信息、内存信息、JVM 系统和环境属性、垃圾回收信息、日志设置和查看、定时任务查看、Spring Boot 缓存查看和管理等功能。接下来我们一起来搭建和使用吧。</p><p>它最终的展示效果如下：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-9215433713186400659-1dcd4e56.webp" alt="image.png"></p><h2 id="1-搭建SBA监控端"><a href="#1-搭建SBA监控端" class="headerlink" title="1.搭建SBA监控端"></a>1.搭建SBA监控端</h2><p>我们需要创建一个 Spring Boot Admin 项目，用来监控和管理我们的 Spring Boot 项目，搭建的方式和创建普通的 Spring Boot 项目类似，具体步骤如下。</p><p>使用 Idea 创建一个 Spring Boot 项目：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-4966016634152584812-9f627859.webp" alt="image.png"></p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-4331006848640308940-f9a81178.webp" alt="image.png"></p><p>这里需要注意，需要添加 Spring Boot Admin（Server）服务端框架的支持，如下图所示：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-140908235938332101-a9d56d14.webp" alt="image.png"></p><p>也就是创建的 Spring Boot 项目需要添加以下两个重要的框架支持：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;de.codecentric&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="1-1-开启SBA服务"><a href="#1-1-开启SBA服务" class="headerlink" title="1.1 开启SBA服务"></a>1.1 开启SBA服务</h3><p>创建完项目之后，需要在启动类上开启 SBA 服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.codecentric.boot.admin.server.config.EnableAdminServer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableAdminServer</span> <span class="comment">// 添加此行代码</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SbaserverApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(SbaserverApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-配置SBA端口号"><a href="#1-2-配置SBA端口号" class="headerlink" title="1.2 配置SBA端口号"></a>1.2 配置SBA端口号</h3><p>在 application.properties 中配置一个项目的端口号就可以直接启动了，我配置的端口号是 9001：</p><figure class="highlight xml"><figcaption><span>copyable</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=9001</span><br></pre></td></tr></table></figure><blockquote><p>PS：配置端口号的主要目的是为了不和其他 Spring Boot 项目冲突，如果 SBA 是单独部署此步骤可以忽略。</p></blockquote><p>启动项目之后，就可以看到 SBA 的主页了，如下图所示：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-5034188976132089120-e22c24c1.webp" alt="image.png"></p><p>此时 SBA 中还没有添加任何需要监控的项目，接下来我们再创建一个 Spring Boot 项目，加入到 SBA 中来进行监控和管理吧。</p><h2 id="2-创建一个普通SpringBoot项目"><a href="#2-创建一个普通SpringBoot项目" class="headerlink" title="2.创建一个普通SpringBoot项目"></a>2.创建一个普通SpringBoot项目</h2><p>首先，我们需要创建一个普通的 Spring Boot 项目，具体的创建步骤这里就不演示了。当创建好 Spring Boot 项目之后，需要在这个 Spring Boot 项目中需要添加 SBA 客户端框架的支持，也就是在 pom.xml 中配置如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>de.codecentric<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 application.properties 文件中配置 SBA 服务器端地址，也就是咱们第一步创建 SBA 项目的地址，配置内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 当前项目端口号</span><br><span class="line">server.port=8080</span><br><span class="line"># Spring Boot Admin 监控服务器端地址</span><br><span class="line">spring.boot.admin.client.url=http://localhost:9001</span><br></pre></td></tr></table></figure><p>其中“spring.boot.admin.client.url”为 SBA 监控地址。</p><h2 id="3-SpringBootAdmin监控总览"><a href="#3-SpringBootAdmin监控总览" class="headerlink" title="3.SpringBootAdmin监控总览"></a>3.SpringBootAdmin监控总览</h2><p>配置完以上信息之后，此时查看 Spring Boot Admin 页面中就有被监控的 Spring Boot 项目了，如下图所示：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-1445691813286336184-86cc2531.webp" alt="image.png"></p><p>也可以点击“应用墙”查看 Spring Boot Admin 中所有被监控的 Spring Boot 项目，如下图所示：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-580441143762849915-71b92a1b.webp" alt="image.png"></p><p>点击应用进入详情页面，如下图所示：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-7806936287450675970-c3d17af2.webp" alt="image.png"><br><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-1238019469429496375-4bede4e4.webp" alt="image.png"></p><p>事件日志中包含 Spring Boot 各种状态的展示（UP 为正常、OFFLINE 为异常）和发生的时间，如下图所示：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-8393710369213936266-b95c219c.webp" alt="image.png"></p><h2 id="4-SpringBoot异常监控"><a href="#4-SpringBoot异常监控" class="headerlink" title="4.SpringBoot异常监控"></a>4.SpringBoot异常监控</h2><p>当我们手动把被监控的 Spring Boot 项目停止之后，在 Spring Boot Admin 中就可以查看到一个应用已经被停掉了，如下图所示：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-993947716579870216-bf8db17f.webp" alt="image.png"></p><p>我们也可以通过事件日志查看 Spring Boot 宕机的具体时间，如下图所示：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-7446785341825628449-f7eab9b3.webp" alt="image.png"></p><h2 id="5-配置查看更多监控项"><a href="#5-配置查看更多监控项" class="headerlink" title="5.配置查看更多监控项"></a>5.配置查看更多监控项</h2><p>通过上面的内容我们可以看出，监控的 Spring Boot 选项还是比较少的，怎么才能查看更多的监控项呢？ 要解决这个问题，我们需要在被监控的 Spring Boot 项目中添加 spring-boot-starter-actuator 框架的支持，并开启查看所有监控项的配置才行，最终展示效果如下：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-7490442428031042011-debcd1eb.webp" alt="image.png"></p><p>接下来我们来配置一下这些监控项。</p><h3 id="5-1-添加actuator框架支持"><a href="#5-1-添加actuator框架支持" class="headerlink" title="5.1 添加actuator框架支持"></a>5.1 添加actuator框架支持</h3><p>在被监控的 Spring Boot 项目中添加 actuator 框架支持，也就是在 pom.xml 中添加以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>手动点击 Maven 导入依赖包（如果开启了自动导入，此步骤可忽略）。</p><h3 id="5-2-配置开放所有监控项"><a href="#5-2-配置开放所有监控项" class="headerlink" title="5.2 配置开放所有监控项"></a>5.2 配置开放所有监控项</h3><p>在被监控的 Spring Boot 项目中添加以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开启监控所有项</span><br><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure><p>以上的配置是开放监控所有选项，配置完之后，重启此 Spring Boot 项目，然后再刷新 Spring Boot Admin 更多的监控项就展示出来了，如下图所示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1418164c3874a579b480ba97c52b468~tplv-k3u1fbpfcp-watermark.awebp" alt="image.png"></p><h3 id="5-3-监控项目预览"><a href="#5-3-监控项目预览" class="headerlink" title="5.3 监控项目预览"></a>5.3 监控项目预览</h3><p>将 Spring Boot 的所有监控项都开启之后，通过 SBA 就可以查看以下内容了：</p><ul><li>启动时间、累计运行时间；</li><li>进程和线程数量和占用的 CPU 资源；</li><li>垃圾回收详情信息，回收次数和花费时间；</li><li>JVM 线程转储、内存转储详情和对应的文件下载；</li><li>可以查看和配置 Spring Boot 项目中的日志级别；</li><li>查看 Spring Boot 项目性能监控；</li><li>查看 Spring Boot 运行环境信息；</li><li>查看 Spring Boot 所有类信息；</li><li>查看 Spring Boot 中的定时任务；</li><li>查看和管理 Spring Boot 项目中的所有缓存。</li></ul><p>以下是几个重要页面的截图，我们一起来看。</p><h4 id="5-3-1-查看运行环境"><a href="#5-3-1-查看运行环境" class="headerlink" title="5.3.1 查看运行环境"></a>5.3.1 查看运行环境</h4><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-3941078158060971189-7b029ef6.webp" alt="image.png"></p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-2053118546997934619-354f16b3.webp" alt="image.png"></p><h4 id="5-3-2-查看定时任务"><a href="#5-3-2-查看定时任务" class="headerlink" title="5.3.2 查看定时任务"></a>5.3.2 查看定时任务</h4><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-6035926923342822535-e8ec2ac2.webp" alt="image.png"></p><h4 id="5-3-3-项目日志级别配置"><a href="#5-3-3-项目日志级别配置" class="headerlink" title="5.3.3 项目日志级别配置"></a>5.3.3 项目日志级别配置</h4><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-4561863301436635032-dcbfd6b2.webp" alt="image.png"></p><p>我们可以通过 Spring Boot Admin 来动态的配置项目中的日志级别。</p><h4 id="5-3-4-JVM线程和内存查看"><a href="#5-3-4-JVM线程和内存查看" class="headerlink" title="5.3.4 JVM线程和内存查看"></a>5.3.4 JVM线程和内存查看</h4><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-579963523500106854-0dd551ad.webp" alt="image.png"></p><h4 id="5-3-5-查看SpringBoot所有缓存"><a href="#5-3-5-查看SpringBoot所有缓存" class="headerlink" title="5.3.5 查看SpringBoot所有缓存"></a>5.3.5 查看SpringBoot所有缓存</h4><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-6225086636997658869-9d1fbce9.webp" alt="image.png"></p><p>当然我们还可以对这些缓存进行删除操作。</p><h2 id="6-查看项目实时日志"><a href="#6-查看项目实时日志" class="headerlink" title="6.查看项目实时日志"></a>6.查看项目实时日志</h2><p>想要查看监控项目中的日志信息，有一个前提条件，前提条件是你被监控的 Spring Boot 项目，必须配置了日志的保存路径或者日志保存文件名，只有配置这两项中的任意一项，你的 Spring Boot 项目才会将日志保存到磁盘上，这样才能通过 SBA 查看到，我配置的是日志路径，在 Spring Boot 的 application.properties 配置文件中添加以下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置日志保存路径</span><br><span class="line">logging.file.path=C:\\work\\log</span><br></pre></td></tr></table></figure><p>设置完成之后，重启你的 Spring Boot 项目，然后刷新 SBA 页面，最终展示效果如下：</p><p><img src="https://b3logfile.com/file/2022/03/solo-fetchupload-855312402918264777-adbc0133.webp" alt="image.png"></p><p>此时我们就可以查看实时的日志信息了，当然你也可以随时下载日志，如果需要的话。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring Boot Admin（SBA）是一个社区开源项目，用于管理和监视 Spring Boot 应用程序，它提供详细的健康 （Health）信息、内存信息、JVM 系统和环境属性、垃圾回收信息、日志设置和查看、定时任务查看、Spring Boot 缓存查看和管理等功能。</p><p>我们需要创建一个 SBA 服务器端用来监控一个或多个 Spring Boot 项目，被监控的 Spring Boot 项目要添加 SBA Client 框架的支持，且添加 actuator 框架和相应的配置，就可以实现对 Spring Boot 项目的完美监控了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> SpringBootAdmin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intellij IDEA 高效使用教程(插件)</title>
      <link href="//articles/2021/12/09/1639029495498.html"/>
      <url>//articles/2021/12/09/1639029495498.html</url>
      
        <content type="html"><![CDATA[<h1 id="Intellij-IDEA-高效使用教程（插件）"><a href="#Intellij-IDEA-高效使用教程（插件）" class="headerlink" title="Intellij IDEA 高效使用教程（插件）"></a>Intellij IDEA 高效使用教程（插件）</h1><p>安装好Intellij idea之后，进行如下的初始化操作，工作效率提升十倍。</p><h2 id="一-安装插件"><a href="#一-安装插件" class="headerlink" title="一. 安装插件"></a>一. 安装插件</h2><p><strong>1. Codota 代码智能提示插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-2069949241295073283-8d1ab5af.webp" alt="图片"></p><p>只要打出首字母就能联想出一整条语句，这也太智能了，还显示了每条语句使用频率。</p><p>原因是它学习了我的项目代码，总结出了我的代码偏好。</p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-6341152902950643044-1336749f.webp" alt="图片"></p><p><strong>如果让它再加上机器学习，人工智能写代码的时代还会远吗？</strong></p><p><strong>2. Key Promoter X 快捷键提示插件</strong></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>每次都会在右下角弹窗提示，帮助我们快速熟悉快捷键。</p><p><strong>3. CodeGlance 显示代码缩略图插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-3986026699248871484-7a34dc46.webp" alt="图片"></p><p>当代码很多的时候，方便查看，很有用。</p><p><strong>4. Lombok 简化臃肿代码插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-5406015942864567475-e5a2a4ed.webp" alt="图片"></p><p>实体类中的get&#x2F;set&#x2F;构造&#x2F;toString&#x2F;hashCode等方法，都不需要我们再手动写了</p><p><strong>5. Alibaba Java Coding Guidelines 阿里巴巴代码规范检查插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-8910796448170792652-74e9cfb2.webp" alt="图片"></p><p>会按照阿里Java开发手册上规范帮我们检查代码，然后对代码做不同颜色展示，鼠标放上去，会看到提示内容，帮助我们写出更规范的代码。</p><p><strong>6. CamelCase 驼峰命名和下划线命名转换</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-5723017167194504650-b7124b76.webp" alt="图片"></p><p>这几种风格的命名方式，用快捷键 ⇧ + ⌥ + U &#x2F; Shift + Alt + U可以进行快速转换，当我们需要修改大量变量名称的时候很方便。</p><p><strong>7. MybatisX 高效操作Mybatis插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-2777196467742761734-645d980f.webp" alt="图片"></p><p><strong>8. SonarLint 代码质量检查插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-3631286403618567907-8d55b69c.webp" alt="图片"></p><p>提示我不要用System.out输出，要用logger输出，诸如此类，帮助我们提升代码质量。</p><p><strong>9. Save Actions 格式化代码插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-2012613769439825696-aaeb8236.webp" alt="图片"></p><p>可以帮忙我们优化包导入，自动给没有修改的变量添加final修饰符，调用方法的时候自动添加this关键字等，使我们的代码更规范统一。</p><p><strong>10. CheckStyle 代码风格检查插件</strong></p><p>功能跟Alibaba Java Coding Guidelines类似</p><p><strong>11. Grep Console 自定义控制台输出格式插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-2544995410612683380-c7d7d961.webp" alt="图片"></p><p><strong>12. MetricsReloaded 代码复杂度检查插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-6775552316988801469-27209de0.webp" alt="图片"></p><p><strong>13. Statistic 代码统计插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-8840834194363532713-18dd86df.webp" alt="图片"></p><p><strong>14. Translation 翻译插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-3253005181190514667-7edac1ca.webp" alt="图片"></p><p><strong>15. Rainbow Brackets 彩虹括号插件</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-1735221263149827559-097c8b03.webp" alt="图片"></p><p>成对儿的括号显示相同的颜色，有了这个插件，我的近视都好了。</p><h2 id="二-自定义创建live-template，快速写代码"><a href="#二-自定义创建live-template，快速写代码" class="headerlink" title="二. 自定义创建live template，快速写代码"></a>二. 自定义创建live template，快速写代码</h2><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-3010163089477214666-4c6ced67.webp" alt="图片"></p><p>只要输入<strong>apr</strong> ，就能自动提示，并且生成<strong>Autowired</strong> 语句了。可以根据自己的代码习惯，自定义一些代码模板，帮助我们快速写代码。</p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-8201793919251786293-dffaaa10.webp" alt="图片"></p><h2 id="三-修改全局配置，提升工作效率"><a href="#三-修改全局配置，提升工作效率" class="headerlink" title="三. 修改全局配置，提升工作效率"></a>三. 修改全局配置，提升工作效率</h2><p><strong>1. 优化导包配置</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-6103759833704813512-0ab02228.webp" alt="图片"></p><p><strong>2. 取消tab页单行显示</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-3672766011502900578-721d96e9.webp" alt="图片"></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-3251612717484556922-983d975d.webp" alt="图片"></p><p>多行显示更多的文件，方便查看。</p><p><strong>3. 双斜杠注释改成紧跟代码头</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-5044486094034362016-14355efa.webp" alt="图片"></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-2575772614443514969-afd8bab8.webp" alt="图片"></p><p><strong>4. 选中复制整行</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-5379164632966494878-ed26fa28.webp" alt="图片"></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-1851181668772931879-5f0b3f96.webp" alt="图片"></p><p>原本只会复制你选中的代码，改完配置后，就能复制整行，无论你是否完全选中。</p><p><strong>5. 取消匹配大小写</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-5845891536010864922-236dfcea.webp" alt="图片"></p><p>取消勾选后，输入小写 <strong>s</strong> ，也能提示出 <strong>String</strong></p><p><strong>6. 优化版本控制的目录颜色展示</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-8943989374416043786-547e7a3d.webp" alt="图片"></p><p><strong>7. 创建文件时，自动生成作者和时间信息</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-8251407680868938477-caa89ea7.webp" alt="图片"></p><p><strong>8 . 显示行号和方法分割线</strong></p><p><img src="https://b3logfile.com/file/2021/12/solo-fetchupload-3370967836657706318-ade1f726.webp" alt="图片"></p><p><strong>你还知道哪些关于Intelij idea高效操作或插件呢？</strong></p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IntellijIDEA </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL对JSON类型的使用/查询/函数</title>
      <link href="//articles/2021/12/08/1638944634446.html"/>
      <url>//articles/2021/12/08/1638944634446.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-对记录的操作"><a href="#一-对记录的操作" class="headerlink" title="一,对记录的操作"></a>一,对记录的操作</h1><p>1.创建有json字段的表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE t_json(id INT PRIMARY KEY, sname VARCHAR(20) , info  JSON);</span><br></pre></td></tr></table></figure><p>2.插入记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 插入含有json数组的记录</span><br><span class="line">INSERT INTO t_json(id,sname,info) VALUES( 1, &#x27;name1&#x27;, JSON_ARRAY(1, &quot;abc&quot;, NULL, TRUE, CURTIME()));</span><br><span class="line"></span><br><span class="line">-- 插入含有json对象的记录</span><br><span class="line">INSERT INTO t_json(id,sname,info) VALUES( 2, &#x27;name2&#x27;, JSON_OBJECT(&quot;age&quot;, 20, &quot;time&quot;, now()));</span><br><span class="line">INSERT INTO t_json(id,sname,info) VALUES( 3, &#x27;name3&#x27;, &#x27;&#123;&quot;age&quot;:20, &quot;time&quot;:&quot;2018-07-14 10:52:00&quot;&#125;&#x27;);</span><br></pre></td></tr></table></figure><p>3.查询记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 查询记录</span><br><span class="line">SELECT sname,JSON_EXTRACT(info,&#x27;$.age&#x27;) FROM t_json;</span><br><span class="line">SELECT sname,info-&gt;&#x27;$.age&#x27; FROM t_json;</span><br><span class="line">-- 查询key</span><br><span class="line">SELECT id,json_keys(info) FROM t_json;</span><br></pre></td></tr></table></figure><p>4.修改记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 增加键</span><br><span class="line">UPDATE t_json SET info = json_set(info,&#x27;$.ip&#x27;,&#x27;192.168.1.1&#x27;) WHERE id = 2;</span><br><span class="line"></span><br><span class="line">-- 变更值</span><br><span class="line">UPDATE t_json SET info = json_set(info,&#x27;$.ip&#x27;,&#x27;192.168.1.2&#x27;) WHERE id = 2;</span><br><span class="line"></span><br><span class="line">-- 删除键</span><br><span class="line">UPDATE t_json SET info = json_remove(info,&#x27;$.ip&#x27;) WHERE id = 2;</span><br></pre></td></tr></table></figure><h1 id="二-创建json值函数"><a href="#二-创建json值函数" class="headerlink" title="二,创建json值函数"></a>二,创建json值函数</h1><p>1.JSON_ARRAY 生成json数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_ARRAY(val1,val2,val3...)</span><br><span class="line">-- 生成一个包含指定元素的json数组。</span><br><span class="line">SELECT JSON_ARRAY(1, &quot;abc&quot;, NULL, TRUE, CURTIME()); -- [1, &quot;abc&quot;, null, true, &quot;10:37:08.000000&quot;]</span><br></pre></td></tr></table></figure><p>2.JSON_OBJECT 生成json对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_OBJECT(key1,val1,key2,val2...)</span><br><span class="line">-- 生成一个包含指定K-V对的json object。如果有key为NULL或参数个数为奇数，则抛错。</span><br><span class="line">SELECT JSON_OBJECT(&#x27;age&#x27;, 20, &#x27;time&#x27;, now()); -- &#123;&quot;age&quot;: 20, &quot;time&quot;: &quot;2021-06-18 14:49:57.000000&quot;&#125;</span><br></pre></td></tr></table></figure><p>3.JSON_QUOTE 加”号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_QUOTE(json_val)</span><br><span class="line">-- 将json_val用&quot;号括起来。</span><br><span class="line">SELECT JSON_QUOTE(&#x27;[1,2,3]&#x27;); -- &quot;[1,2,3]&quot;</span><br></pre></td></tr></table></figure><h1 id="三-搜索json值函数"><a href="#三-搜索json值函数" class="headerlink" title="三,搜索json值函数"></a>三,搜索json值函数</h1><p>1.JSON_CONTAINS 指定数据是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set @j = &#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: &#123;&quot;d&quot;: 4&#125;&#125;&#x27;;</span><br><span class="line">-- JSON_CONTAINS(json_doc, val[, path])</span><br><span class="line">-- 查询json文档是否在指定path包含指定的数据，包含则返回1，否则返回0。如果有参数为NULL或path不存在，则返回NULL。</span><br><span class="line">SELECT JSON_CONTAINS(@j, &#x27;4&#x27;, &#x27;$.c.d&#x27;); -- 1</span><br></pre></td></tr></table></figure><p>2.JSON_CONTAINS_PATH 指定路径是否存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_CONTAINS_PATH(json_doc, one_or_all, path[, path] ...)</span><br><span class="line">-- 查询是否存在指定路径，存在则返回1，否则返回0。如果有参数为NULL，则返回NULL。</span><br><span class="line">-- one_or_all只能取值&quot;one&quot;或&quot;all&quot;，one表示只要有一个存在即可；all表示所有的都存在才行。</span><br><span class="line">SELECT JSON_CONTAINS_PATH(@j, &#x27;one&#x27;, &#x27;$.a&#x27;, &#x27;$.e&#x27;); -- 1</span><br><span class="line">SELECT JSON_CONTAINS_PATH(@j, &#x27;all&#x27;, &#x27;$.a&#x27;, &#x27;$.c.d&#x27;); -- 1</span><br></pre></td></tr></table></figure><p>3.JSON_EXTRACT 查找所有指定数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_EXTRACT(json_doc, path[, path] ...)</span><br><span class="line">-- 从json文档里抽取数据。如果有参数有NULL或path不存在，则返回NULL。如果抽取出多个path，则返回的数据封闭在一个json array里。</span><br><span class="line">set @j2 = &#x27;[10, 20, [30, 40]]&#x27;;</span><br><span class="line">SELECT JSON_EXTRACT(&#x27;[10, 20, [30, 40]]&#x27;, &#x27;$[1]&#x27;); -- 20</span><br><span class="line">SELECT JSON_EXTRACT(&#x27;[10, 20, [30, 40]]&#x27;, &#x27;$[1]&#x27;, &#x27;$[0]&#x27;); -- [20, 10]</span><br><span class="line">SELECT JSON_EXTRACT(&#x27;[10, 20, [30, 40]]&#x27;, &#x27;$[2][*]&#x27;); -- [30, 40]</span><br></pre></td></tr></table></figure><p>4.JSON_KEYS 查找所有指定键值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_KEYS(json_doc[, path])</span><br><span class="line">-- 获取json文档在指定路径下的所有键值，返回一个json array。如果有参数为NULL或path不存在，则返回NULL。</span><br><span class="line">SELECT JSON_KEYS(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 30&#125;&#125;&#x27;); -- [&quot;a&quot;, &quot;b&quot;]</span><br><span class="line">SELECT JSON_KEYS(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 30&#125;&#125;&#x27;, &#x27;$.b&#x27;); -- [&quot;c&quot;]</span><br><span class="line">SELECT id,json_keys(info) FROM t_json;</span><br></pre></td></tr></table></figure><p>5.JSON_SEARCH 查找所有指定值的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_SEARCH(json_doc, one_or_all, search_str[, escape_char[, path] ...])</span><br><span class="line">-- 查询包含指定字符串的paths，并作为一个json array返回。如果有参数为NUL或path不存在，则返回NULL。</span><br><span class="line">-- one_or_all：&quot;one&quot;表示查询到一个即返回；&quot;all&quot;表示查询所有。</span><br><span class="line">-- search_str：要查询的字符串。 可以用LIKE里的&#x27;%&#x27;或‘_’匹配。</span><br><span class="line">-- path：在指定path下查。</span><br><span class="line">SET @j3 = &#x27;[&quot;abc&quot;, [&#123;&quot;k&quot;: &quot;10&quot;&#125;, &quot;def&quot;], &#123;&quot;x&quot;:&quot;abc&quot;&#125;, &#123;&quot;y&quot;:&quot;bcd&quot;&#125;]&#x27;;</span><br><span class="line">SELECT JSON_SEARCH(@j3, &#x27;one&#x27;, &#x27;abc&#x27;); -- &quot;$[0]&quot;</span><br><span class="line">SELECT JSON_SEARCH(@j3, &#x27;all&#x27;, &#x27;abc&#x27;); -- [&quot;$[0]&quot;, &quot;$[2].x&quot;]</span><br><span class="line">SELECT JSON_SEARCH(@j3, &#x27;all&#x27;, &#x27;abc&#x27;, NULL, &#x27;$[2]&#x27;); -- &quot;$[2].x&quot;</span><br><span class="line">SELECT JSON_SEARCH(@j3, &#x27;all&#x27;, &#x27;10&#x27;); -- &quot;$[1][0].k&quot;</span><br><span class="line">SELECT JSON_SEARCH(@j3, &#x27;all&#x27;, &#x27;%b%&#x27;); -- [&quot;$[0]&quot;, &quot;$[2].x&quot;, &quot;$[3].y&quot;]</span><br><span class="line">SELECT JSON_SEARCH(@j3, &#x27;all&#x27;, &#x27;%b%&#x27;, NULL, &#x27;$[2]&#x27;); -- &quot;$[2].x&quot;</span><br></pre></td></tr></table></figure><h1 id="四-修改json值函数"><a href="#四-修改json值函数" class="headerlink" title="四,修改json值函数"></a>四,修改json值函数</h1><p>1.JSON_ARRAY_APPEND  指定位置追加数组元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_ARRAY_APPEND(json_doc, path, val[, path, val] ...)</span><br><span class="line">-- 在指定path的json array尾部追加val。如果指定path是一个json object，则将其封装成一个json array再追加。如果有参数为NULL，则返回NULL。</span><br><span class="line">SET @j4 = &#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;]&#x27;;</span><br><span class="line">-- SELECT JSON_ARRAY_APPEND(@j4, &#x27;$[1][0]&#x27;, 3); -- [&quot;a&quot;, [[&quot;b&quot;, 3], &quot;c&quot;], &quot;d&quot;]</span><br><span class="line">SET @j5 = &#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;c&quot;: 4&#125;&#x27;;</span><br><span class="line">SELECT JSON_ARRAY_APPEND(@j5, &#x27;$.b&#x27;, &#x27;x&#x27;); -- &#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3, &quot;x&quot;], &quot;c&quot;: 4&#125; </span><br><span class="line">SELECT JSON_ARRAY_APPEND(@j5, &#x27;$.c&#x27;, &#x27;y&#x27;); -- &#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;c&quot;: [4, &quot;y&quot;]&#125;</span><br><span class="line">SELECT JSON_ARRAY_APPEND(@j5, &#x27;$&#x27;, &#x27;z&#x27;); -- [&#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;c&quot;: 4&#125;, &quot;z&quot;]</span><br></pre></td></tr></table></figure><p>2.JSON_ARRAY_INSERT 指定位置插入数组元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_ARRAY_INSERT(json_doc, path, val[, path, val] ...)</span><br><span class="line">-- 在path指定的json array元素插入val，原位置及以右的元素顺次右移。如果path指定的数据非json array元素，则略过此val；如果指定的元素下标超过json array的长度，则插入尾部。</span><br><span class="line">SET @j6 = &#x27;[&quot;a&quot;, &#123;&quot;b&quot;: [1, 2]&#125;, [3, 4]]&#x27;;</span><br><span class="line">SELECT JSON_ARRAY_INSERT(@j6, &#x27;$[1]&#x27;, &#x27;x&#x27;); -- [&quot;a&quot;, &quot;x&quot;, &#123;&quot;b&quot;: [1, 2]&#125;, [3, 4]]</span><br><span class="line">SELECT JSON_ARRAY_INSERT(@j6, &#x27;$[100]&#x27;, &#x27;x&#x27;); -- [&quot;a&quot;, &#123;&quot;b&quot;: [1, 2]&#125;, [3, 4], &quot;x&quot;]</span><br><span class="line">SELECT JSON_ARRAY_INSERT(@j6, &#x27;$[1].b[0]&#x27;, &#x27;x&#x27;); -- [&quot;a&quot;, &#123;&quot;b&quot;: [&quot;x&quot;, 1, 2]&#125;, [3, 4]]</span><br><span class="line">SELECT JSON_ARRAY_INSERT(@j6, &#x27;$[0]&#x27;, &#x27;x&#x27;, &#x27;$[3][1]&#x27;, &#x27;y&#x27;); -- [&quot;x&quot;, &quot;a&quot;, &#123;&quot;b&quot;: [1, 2]&#125;, [3, &quot;y&quot;, 4]]</span><br></pre></td></tr></table></figure><p>3.JSON_INSERT 指定位置插入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_INSERT(json_doc, path, val[, path, val] ...)</span><br><span class="line">-- 在指定path下插入数据，如果path已存在，则忽略此val（不存在才插入）。</span><br><span class="line">SET @j7 = &#x27;&#123; &quot;a&quot;: 1, &quot;b&quot;: [2, 3]&#125;&#x27;;</span><br><span class="line">SELECT JSON_INSERT(@j7, &#x27;$.a&#x27;, 10, &#x27;$.c&#x27;, &#x27;[true, false]&#x27;); -- &#123;&quot;a&quot;: 1, &quot;b&quot;: [2, 3], &quot;c&quot;: &quot;[true, false]&quot;&#125;</span><br></pre></td></tr></table></figure><p>4.JSON_REPLACE 指定位置替换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_REPLACE(json_doc, path, val[, path, val] ...)</span><br><span class="line">-- 替换指定路径的数据，如果某个路径不存在则略过（存在才替换）。如果有参数为NULL，则返回NULL。</span><br><span class="line">SELECT JSON_REPLACE(@j7, &#x27;$.a&#x27;, 10, &#x27;$.c&#x27;, &#x27;[true, false]&#x27;); -- &#123;&quot;a&quot;: 10, &quot;b&quot;: [2, 3]&#125;</span><br></pre></td></tr></table></figure><p>5.JSON_SET 指定位置设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_SET(json_doc, path, val[, path, val] ...)</span><br><span class="line">-- 设置指定路径的数据（不管是否存在）。如果有参数为NULL，则返回NULL。</span><br><span class="line">SELECT JSON_SET(@j7, &#x27;$.a&#x27;, 10, &#x27;$.c&#x27;, &#x27;[true, false]&#x27;); -- &#123;&quot;a&quot;: 10, &quot;b&quot;: [2, 3], &quot;c&quot;: &quot;[true, false]&quot;&#125;</span><br></pre></td></tr></table></figure><p>6.JSON_MERGE 合并</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_MERGE(json_doc, json_doc[, json_doc] ...)</span><br><span class="line">-- merge多个json文档。规则如下：</span><br><span class="line">-- 如果都是json array，则结果自动merge为一个json array；</span><br><span class="line">-- 如果都是json object，则结果自动merge为一个json object；</span><br><span class="line">-- 如果有多种类型，则将非json array的元素封装成json array再按照规则一进行mege。</span><br><span class="line">SELECT JSON_MERGE(&#x27;[1, 2]&#x27;, &#x27;[true, false]&#x27;); -- [1, 2, true, false]</span><br><span class="line">SELECT JSON_MERGE(&#x27;&#123;&quot;name&quot;: &quot;x&quot;&#125;&#x27;, &#x27;&#123;&quot;id&quot;: 47&#125;&#x27;); -- &#123;&quot;id&quot;: 47, &quot;name&quot;: &quot;x&quot;&#125;</span><br><span class="line">SELECT JSON_MERGE(&#x27;1&#x27;, &#x27;true&#x27;); -- [1, true]</span><br><span class="line">SELECT JSON_MERGE(&#x27;[1, 2]&#x27;, &#x27;&#123;&quot;id&quot;: 47&#125;&#x27;); -- [1, 2, &#123;&quot;id&quot;: 47&#125;]</span><br></pre></td></tr></table></figure><p>7.JSON_REMOVE 指定位置移除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_REMOVE(json_doc, path[, path] ...)</span><br><span class="line">-- 移除指定路径的数据，如果某个路径不存在则略过此路径。如果有参数为NULL，则返回NULL。</span><br><span class="line">SET @j8 = &#x27;[&quot;a&quot;, [&quot;b&quot;, &quot;c&quot;], &quot;d&quot;]&#x27;;</span><br><span class="line">SELECT JSON_REMOVE(@j8, &#x27;$[1]&#x27;); -- [&quot;a&quot;, &quot;d&quot;]</span><br></pre></td></tr></table></figure><p>8.JSON_UNQUOTE 去”号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_UNQUOTE(val)</span><br><span class="line">-- 去掉val的引号。如果val为NULL，则返回NULL。</span><br><span class="line">SELECT JSON_UNQUOTE(&quot;\&quot;123\&quot;&quot;); -- 123</span><br></pre></td></tr></table></figure><h1 id="五-返回json值属性的函数"><a href="#五-返回json值属性的函数" class="headerlink" title="五,返回json值属性的函数"></a>五,返回json值属性的函数</h1><p>1.JSON_DEPTH 深度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_DEPTH(json_doc)</span><br><span class="line">-- 获取json文档的深度。如果参数为NULL，则返回NULL。</span><br><span class="line">-- 空的json array、json object或标量的深度为1。</span><br><span class="line">SELECT JSON_DEPTH(&#x27;&#123;&#125;&#x27;), JSON_DEPTH(&#x27;[]&#x27;), JSON_DEPTH(&#x27;true&#x27;); -- 1 1 1</span><br><span class="line">SELECT JSON_DEPTH(&#x27;[10, 20]&#x27;), JSON_DEPTH(&#x27;[[], &#123;&#125;]&#x27;); -- 2 2</span><br><span class="line">SELECT JSON_DEPTH(&#x27;[10, &#123;&quot;a&quot;: 20&#125;]&#x27;); -- 3</span><br></pre></td></tr></table></figure><p>2.JSON_LENGTH 长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_LENGTH(json_doc[, path])</span><br><span class="line">-- 获取指定路径下的长度。如果参数为NULL，则返回NULL。　</span><br><span class="line">-- 长度的计算规则：</span><br><span class="line">-- 标量的长度为1；</span><br><span class="line">-- json array的长度为元素的个数；</span><br><span class="line">-- json object的长度为key的个数。</span><br><span class="line">SELECT JSON_LENGTH(&#x27;[1, 2, &#123;&quot;a&quot;: 3&#125;]&#x27;); -- 3</span><br><span class="line">SELECT JSON_LENGTH(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 30&#125;&#125;&#x27;); -- 2</span><br><span class="line">SELECT JSON_LENGTH(&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: &#123;&quot;c&quot;: 30&#125;&#125;&#x27;, &#x27;$.b&#x27;); -- 1</span><br></pre></td></tr></table></figure><p>3.JSON_TYPE 类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_TYPE(json_val)</span><br><span class="line">-- 获取json文档的具体类型。如果参数为NULL，则返回NULL。</span><br><span class="line">select JSON_TYPE(&#x27;[1,2]&#x27;); -- ARRAY</span><br></pre></td></tr></table></figure><p>4.JSON_VALID 是否有效json格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- JSON_VALID(val)</span><br><span class="line">-- 判断val是否为有效的json格式，是为1，不是为0。如果参数为NUL，则返回NULL。</span><br><span class="line">SELECT JSON_VALID(&#x27;&#123;&quot;a&quot;: 1&#125;&#x27;); -- 1</span><br><span class="line">SELECT JSON_VALID(&#x27;hello&#x27;), JSON_VALID(&#x27;&quot;hello&quot;&#x27;); -- 1</span><br></pre></td></tr></table></figure><p>附录:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">JSON_ARRAY 生成json数组</span><br><span class="line">JSON_OBJECT 生成json对象</span><br><span class="line">JSON_QUOTE 加&quot;号</span><br><span class="line">JSON_CONTAINS 指定数据是否存在</span><br><span class="line">JSON_CONTAINS_PATH 指定路径是否存在</span><br><span class="line">JSON_EXTRACT 查找所有指定数据</span><br><span class="line">JSON_KEYS 查找所有指定键值</span><br><span class="line">JSON_SEARCH 查找所有指定值的位置</span><br><span class="line">JSON_ARRAY_APPEND  指定位置追加数组元素</span><br><span class="line">JSON_ARRAY_INSERT 指定位置插入数组元素</span><br><span class="line">JSON_INSERT 指定位置插入</span><br><span class="line">JSON_REPLACE 指定位置替换</span><br><span class="line">JSON_SET 指定位置设置</span><br><span class="line">JSON_MERGE 合并</span><br><span class="line">JSON_REMOVE 指定位置移除</span><br><span class="line">JSON_UNQUOTE 去&quot;号</span><br><span class="line">JSON_DEPTH 深度</span><br><span class="line">JSON_LENGTH 长度</span><br><span class="line">JSON_TYPE 类型</span><br><span class="line">JSON_VALID 是否有效json格式</span><br></pre></td></tr></table></figure><table><thead><tr><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-append"><code>JSON_APPEND()</code></a>（废弃的5.7.9）</td><td>JSON文件追加数据</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-creation-functions.html#function_json-array"><code>JSON_ARRAY()</code></a></td><td>创建JSON数组</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-array-append"><code>JSON_ARRAY_APPEND()</code></a></td><td>JSON文件追加数据</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-array-insert"><code>JSON_ARRAY_INSERT()</code></a></td><td>插入JSON数组</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#operator_json-column-path"><code>-&gt;</code></a></td><td>在评估路径返回JSON列值；相当于json_extract()。</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-contains"><code>JSON_CONTAINS()</code></a></td><td>是否包含特定对象的JSON文档路径</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-contains-path"><code>JSON_CONTAINS_PATH()</code></a></td><td>无论是JSON文件包含任何数据路径</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-depth"><code>JSON_DEPTH()</code></a></td><td>JSON文档的最大深度</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-extract"><code>JSON_EXTRACT()</code></a></td><td>从JSON文档返回数据</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#operator_json-inline-path"><code>-&gt;&gt;</code></a></td><td>在评估路径和结束引语结果返回JSON列值；相当于json_unquote（json_extract()）。</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-insert"><code>JSON_INSERT()</code></a></td><td>将数据插入到JSON文档</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-keys"><code>JSON_KEYS()</code></a></td><td>从JSON文件密钥数组</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-length"><code>JSON_LENGTH()</code></a></td><td>在JSON文档中的元素数</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-merge"><code>JSON_MERGE()</code></a>（废弃的5.7.22）</td><td>合并的JSON文件，保存重复键。不json_merge_preserve()的同义词</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-merge-patch"><code>JSON_MERGE_PATCH()</code></a></td><td>合并的JSON文件，免去重复键的值</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-merge-preserve"><code>JSON_MERGE_PRESERVE()</code></a></td><td>合并的JSON文件，保存重复键</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-creation-functions.html#function_json-object"><code>JSON_OBJECT()</code></a></td><td>创建JSON对象</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-utility-functions.html#function_json-pretty"><code>JSON_PRETTY()</code></a></td><td>版画在人类可读的格式JSON文档，每个数组元素或对象成员打印在新的行中，缩进两个空格就其母。</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-creation-functions.html#function_json-quote"><code>JSON_QUOTE()</code></a></td><td>引用JSON文档</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-remove"><code>JSON_REMOVE()</code></a></td><td>从JSON文件中删除数据</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-replace"><code>JSON_REPLACE()</code></a></td><td>在JSON文件的值替换</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-search-functions.html#function_json-search"><code>JSON_SEARCH()</code></a></td><td>在JSON文件价值路径</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-set"><code>JSON_SET()</code></a></td><td>将数据插入到JSON文档</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-utility-functions.html#function_json-storage-size"><code>JSON_STORAGE_SIZE()</code></a></td><td>用于一个JSON文件的二进制表示形式存储空间；一个JSON柱，空间时使用的文档插入到任何部分更新之前，</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-type"><code>JSON_TYPE()</code></a></td><td>JSON值类型</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-modification-functions.html#function_json-unquote"><code>JSON_UNQUOTE()</code></a></td><td>JSON值而言</td></tr><tr><td><a href="https://dev.mysql.com/doc/refman/5.7/en/json-attribute-functions.html#function_json-valid"><code>JSON_VALID()</code></a></td><td>JSON值是否是有效的</td></tr></tbody></table><p>mysql官方文档: <a href="https://dev.mysql.com/doc/refman/5.7/en/json-utility-functions.html">https://dev.mysql.com/doc/refman/5.7/en/json-utility-functions.html</a></p><blockquote><p>参考:<br><a href="https://www.cnblogs.com/waterystone/p/5626098.html">https://www.cnblogs.com/waterystone/p/5626098.html</a>  <br><a href="https://www.cnblogs.com/ooo0/p/9309277.html">https://www.cnblogs.com/ooo0/p/9309277.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 springBoot 实现webSocket方式的扫码登录</title>
      <link href="//articles/2021/12/03/1638516438999.html"/>
      <url>//articles/2021/12/03/1638516438999.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、首先咱们需要一张表"><a href="#一、首先咱们需要一张表" class="headerlink" title="一、首先咱们需要一张表"></a>一、首先咱们需要一张表</h3><p>这表是干啥的呢？就是记录一下谁扫码了。谁登录了。</p><blockquote><p>User_Token表</p></blockquote><p>字段如下：</p><ul><li>uuid : 用于确保唯一性</li><li>userId ：谁登录的</li><li>loginTime ：登录时间</li><li>createTime ：创建时间 用于判断是否过期</li><li>state：是否二维码失效 0有效 1失效</li></ul><h3 id="二、角色都有哪些"><a href="#二、角色都有哪些" class="headerlink" title="二、角色都有哪些"></a>二、角色都有哪些</h3><p>咱们还需要分析一下子。扫码登录这个业务逻辑都有哪些角色</p><ul><li>android端 or 微信Web端 ：扫码</li><li>PC端 ：被扫。登录</li><li>服务端：掌控全局，提供接口。</li></ul><h3 id="三、接口都需要哪些？"><a href="#三、接口都需要哪些？" class="headerlink" title="三、接口都需要哪些？"></a>三、接口都需要哪些？</h3><p>有了角色。你用大腿也能想出来接口了对不对！！</p><p>所以咱们的接口有2个！</p><ul><li>生成二维码接口：生成一个二维码。二维码中有UUID。</li><li>确认身份接口：确定身份以及判断是否二维码过期等</li></ul><h3 id="四、步骤"><a href="#四、步骤" class="headerlink" title="四、步骤"></a>四、步骤</h3><p>那句话怎么说的来着。要把大象装冰箱一共分几步？</p><ul><li>PC端打开。调用生成二维码接口 并与 服务端建立链接。链接使用uuid进行绑定</li><li>微信Web端进行扫码。获取二维码中的uuid。</li><li>微信Web端拿到uuid以后。显示是否登录页面。点击确定后 调用 确认身份接口。</li><li>确认身份接口通过以后。服务端给PC端发送信息。完成登录。此时链接断开。</li></ul><p>好了！分析完了这些。你们一定在想。。还有完没完啊。。不要在BB了。。赶紧贴代码吧。。</p><blockquote><p>作者：观众老爷们。我这是在教给你们如何思考的方法呀?</p></blockquote><p>那么开始贴代码吧！希望大家在看到的同时也可以自己进行思考。</p><h3 id="五、疯狂贴代码"><a href="#五、疯狂贴代码" class="headerlink" title="五、疯狂贴代码"></a>五、疯狂贴代码</h3><p>首先需要获取二维码的代码对不对！贴！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//获取登录二维码、放入Token</span><br><span class="line">@RequestMapping(value = &quot;/getLoginQr&quot; ,method = RequestMethod.GET)</span><br><span class="line">public void createCodeImg(HttpServletRequest request, HttpServletResponse response)&#123;</span><br><span class="line">    response.setHeader(&quot;Pragma&quot;, &quot;No-cache&quot;);</span><br><span class="line">    response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;);</span><br><span class="line"> </span><br><span class="line">    response.setDateHeader(&quot;Expires&quot;, 0);</span><br><span class="line">    response.setContentType(&quot;image/jpeg&quot;);</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">        //这里没啥操作 就是生成一个UUID插入 数据库的表里</span><br><span class="line">        String uuid = userService.createQrImg();</span><br><span class="line">        response.setHeader(&quot;uuid&quot;, uuid);</span><br><span class="line">        // 这里是开源工具类 hutool里的QrCodeUtil </span><br><span class="line">        // 网址：http://hutool.mydoc.io/</span><br><span class="line">        QrCodeUtil.generate(uuid, 300, 300, &quot;jpg&quot;,response.getOutputStream());</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了获取二维码的接口。相对的前端需要调用。</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><blockquote><p>知识点：动态加载图片流并取出header中的参数</p></blockquote><p>这里使用了xmlhttp进行处理。</p><p>为什么？</p><p>因为后端返回的是一个流。</p><p>那么流中。就是放置了二维码中的uuid。这个uuid作为一次会话的标识符使用。</p><p>那么前端也需要拿到。跟后端进行webSocket链接。</p><p>这样有人扫码后。服务端才可以使用webSocket的方式通知前端。有人扫码成功了。你做你的业务吧。酱紫。</p><p>所以为了拿到请求中 header中放置的uuid 所以这样通过xmlhttp进行处理</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;qrCodeImg-box&quot; id=&quot;qrImgDiv&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">initQrImg();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> function initQrImg()&#123;</span><br><span class="line">    $(&quot;#qrImgDiv&quot;).empty();</span><br><span class="line"> </span><br><span class="line">    var xmlhttp;</span><br><span class="line">    xmlhttp=new XMLHttpRequest();</span><br><span class="line">    xmlhttp.open(&quot;GET&quot;,getQrPath,true);</span><br><span class="line">    xmlhttp.responseType = &quot;blob&quot;;</span><br><span class="line">    xmlhttp.onload = function()&#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">        uuid = this.getResponseHeader(&quot;uuid&quot;);</span><br><span class="line"> </span><br><span class="line">        if (this.status == 200) &#123;</span><br><span class="line">            var blob = this.response;</span><br><span class="line">            var img = document.createElement(&quot;img&quot;);</span><br><span class="line">            img.className = &#x27;qrCodeBox-img&#x27;;</span><br><span class="line">            img.onload = function(e) &#123;</span><br><span class="line">                window.URL.revokeObjectURL(img.src);</span><br><span class="line">            &#125;;</span><br><span class="line">            img.src = window.URL.createObjectURL(blob);</span><br><span class="line">            document.getElementById(&quot;qrImgDiv&quot;).appendChild(img);</span><br><span class="line"> </span><br><span class="line">            initWebSocket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xmlhttp.send();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">var path = &quot;://localhost:8085&quot;;</span><br><span class="line">var getQrPath =  &quot;http&quot; + path + &quot;/user/getLoginQr&quot;;</span><br><span class="line">var wsPath =     &quot;ws&quot; + path + &quot;/websocket/&quot;;</span><br><span class="line"> </span><br><span class="line">function initWebSocket()&#123;</span><br><span class="line"> </span><br><span class="line">   if(typeof(WebSocket) == &quot;undefined&quot;) &#123;</span><br><span class="line">       console.log(&quot;您的浏览器不支持WebSocket&quot;);</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">       console.log(&quot;您的浏览器支持WebSocket&quot;);</span><br><span class="line">       //实现化WebSocket对象，指定要连接的服务器地址与端口  建立连接</span><br><span class="line">       //等同于socket = new WebSocket(&quot;ws://localhost:8083/checkcentersys/websocket/20&quot;);</span><br><span class="line">       var wsPathStr = wsPath+uuid;</span><br><span class="line">       socket = new WebSocket(wsPathStr);</span><br><span class="line">       //打开事件</span><br><span class="line">       socket.onopen = function() &#123;</span><br><span class="line">           console.log(&quot;Socket 已打开&quot;);</span><br><span class="line">           //socket.send(&quot;这是来自客户端的消息&quot; + location.href + new Date());</span><br><span class="line">       &#125;;</span><br><span class="line">       //获得消息事件</span><br><span class="line">       socket.onmessage = function(msg) &#123;</span><br><span class="line">           console.log(msg.data);</span><br><span class="line">           var data = JSON.parse(msg.data);</span><br><span class="line">           if(data.code == 200)&#123;</span><br><span class="line">               alert(&quot;登录成功！&quot;);</span><br><span class="line">               //这里存放自己业务需要的数据。怎么放自己看</span><br><span class="line">               window.sessionStorage.uuid = uuid;</span><br><span class="line">               window.sessionStorage.userId = data.userId;</span><br><span class="line">               window.sessionStorage.projId = data.projId;</span><br><span class="line"> </span><br><span class="line">               window.location.href = &quot;pages/upload.html&quot;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               //如果过期了，关闭连接、重置连接、刷新二维码</span><br><span class="line">               socket.close();</span><br><span class="line">               initQrImg();</span><br><span class="line">           &#125;</span><br><span class="line">           //发现消息进入    开始处理前端触发逻辑</span><br><span class="line">       &#125;;</span><br><span class="line">       //关闭事件</span><br><span class="line">       socket.onclose = function() &#123;</span><br><span class="line">           console.log(&quot;Socket已关闭&quot;);</span><br><span class="line">       &#125;;</span><br><span class="line">       //发生了错误事件</span><br><span class="line">       socket.onerror = function() &#123;</span><br><span class="line">           alert(&quot;Socket发生了错误&quot;);</span><br><span class="line">           //此时可以尝试刷新页面</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了。上面已经提到了前端如何配置webSocket。</p><h3 id="Spring-Boot中操作WebSocket"><a href="#Spring-Boot中操作WebSocket" class="headerlink" title="Spring Boot中操作WebSocket"></a>Spring Boot中操作WebSocket</h3><p>1、增加pom.xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2、增加一个Bean</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * WebSocket的支持</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@Bean</span><br><span class="line">public ServerEndpointExporter serverEndpointExporter() &#123;</span><br><span class="line">    return new ServerEndpointExporter();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、定义WebSocketServer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">package com.stylefeng.guns.rest.modular.inve.websocket;</span><br><span class="line"> </span><br><span class="line">/**</span><br><span class="line"> * Created by jiangjiacheng on 2019/6/4.</span><br><span class="line"> */</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.concurrent.CopyOnWriteArraySet;</span><br><span class="line"> </span><br><span class="line">import javax.websocket.OnClose;</span><br><span class="line">import javax.websocket.OnError;</span><br><span class="line">import javax.websocket.OnMessage;</span><br><span class="line">import javax.websocket.OnOpen;</span><br><span class="line">import javax.websocket.Session;</span><br><span class="line">import javax.websocket.server.PathParam;</span><br><span class="line">import javax.websocket.server.ServerEndpoint;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import cn.hutool.log.Log;</span><br><span class="line">import cn.hutool.log.LogFactory;</span><br><span class="line"> </span><br><span class="line">@ServerEndpoint(&quot;/websocket/&#123;sid&#125;&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class WebSocketServer &#123;</span><br><span class="line"> </span><br><span class="line">    static Log log=LogFactory.get(WebSocketServer.class);</span><br><span class="line"> </span><br><span class="line">    //静态变量，用来记录当前在线连接数。应该把它设计成线程安全的。</span><br><span class="line">    private static int onlineCount = 0;</span><br><span class="line"> </span><br><span class="line">    //concurrent包的线程安全Set，用来存放每个客户端对应的MyWebSocket对象。</span><br><span class="line">    private static CopyOnWriteArraySet&lt;WebSocketServer&gt; webSocketSet = new CopyOnWriteArraySet&lt;WebSocketServer&gt;();</span><br><span class="line"> </span><br><span class="line">    //与某个客户端的连接会话，需要通过它来给客户端发送数据</span><br><span class="line">    private Session session;</span><br><span class="line"> </span><br><span class="line">    //接收sid</span><br><span class="line">    private String sid=&quot;&quot;;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 连接建立成功调用的方法*/</span><br><span class="line">    @OnOpen</span><br><span class="line">    public void onOpen(Session session,@PathParam(&quot;sid&quot;) String sid) &#123;</span><br><span class="line">        this.session = session;</span><br><span class="line">        webSocketSet.add(this);     //加入set中</span><br><span class="line">        addOnlineCount();           //在线数加1</span><br><span class="line">        log.info(&quot;有新窗口开始监听:&quot;+sid+&quot;,当前在线人数为&quot; + getOnlineCount());</span><br><span class="line">        this.sid=sid;</span><br><span class="line">        /*try &#123;</span><br><span class="line">            sendMessage(&quot;连接成功&quot;);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;websocket IO异常&quot;);</span><br><span class="line">        &#125;*/</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 连接关闭调用的方法</span><br><span class="line">     */</span><br><span class="line">    @OnClose</span><br><span class="line">    public void onClose() &#123;</span><br><span class="line">        webSocketSet.remove(this);  //从set中删除</span><br><span class="line">        subOnlineCount();           //在线数减1</span><br><span class="line">        log.info(&quot;有一连接关闭！当前在线人数为&quot; + getOnlineCount());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 收到客户端消息后调用的方法</span><br><span class="line">     *</span><br><span class="line">     * @param message 客户端发送过来的消息*/</span><br><span class="line">    @OnMessage</span><br><span class="line">    public void onMessage(String message, Session session) &#123;</span><br><span class="line">        log.info(&quot;收到来自窗口&quot;+sid+&quot;的信息:&quot;+message);</span><br><span class="line">        //群发消息</span><br><span class="line">        for (WebSocketServer item : webSocketSet) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                item.sendMessage(message);</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param session</span><br><span class="line">     * @param error</span><br><span class="line">     */</span><br><span class="line">    @OnError</span><br><span class="line">    public void onError(Session session, Throwable error) &#123;</span><br><span class="line">        log.error(&quot;发生错误&quot;);</span><br><span class="line">        error.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 实现服务器主动推送</span><br><span class="line">     */</span><br><span class="line">    public void sendMessage(String message) throws IOException &#123;</span><br><span class="line">        this.session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 群发自定义消息</span><br><span class="line">     * */</span><br><span class="line">    public static void sendInfo(String message,@PathParam(&quot;sid&quot;) String sid) throws IOException &#123;</span><br><span class="line">        log.info(&quot;推送消息到窗口&quot;+sid+&quot;，推送内容:&quot;+message);</span><br><span class="line">        for (WebSocketServer item : webSocketSet) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                //这里可以设定只推送给这个sid的，为null则全部推送</span><br><span class="line">                if(sid == null) &#123;</span><br><span class="line">                    item.sendMessage(message);</span><br><span class="line">                &#125;else if(item.sid.equals(sid))&#123;</span><br><span class="line">                    item.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static synchronized int getOnlineCount() &#123;</span><br><span class="line">        return onlineCount;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static synchronized void addOnlineCount() &#123;</span><br><span class="line">        WebSocketServer.onlineCount++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static synchronized void subOnlineCount() &#123;</span><br><span class="line">        WebSocketServer.onlineCount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就增加了webSocket的支持啦。</p><p>1、首先PC端调用接口展示出来了二维码。</p><p>2、请求二维码中的http请求。就有uuid在 header中。直接取到uuid 作为webSocket的标识sid进行连接。</p><p>3、然后手机端使用相机拿到二维码中的uuid。使用uuid + userid 请求 扫码成功接口。</p><p>贴扫码成功接口</p><p>Controller代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 确认身份接口：确定身份以及判断是否二维码过期等</span><br><span class="line"> * @param token</span><br><span class="line"> * @param userId</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(value = &quot;/bindUserIdAndToken&quot; ,method = RequestMethod.GET)</span><br><span class="line">@ResponseBody</span><br><span class="line">public Object bindUserIdAndToken(@RequestParam(&quot;token&quot;) String token ,</span><br><span class="line">                                 @RequestParam(&quot;userId&quot;) Integer userId,</span><br><span class="line">                                 @RequestParam(required = false,value = &quot;projId&quot;) Integer projId)&#123;</span><br><span class="line"> </span><br><span class="line">    try &#123;</span><br><span class="line">        return new SuccessTip(userService.bindUserIdAndToken(userId,token,projId));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        return new ErrorTip(500,e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String bindUserIdAndToken(Integer userId, String token,Integer projId) throws Exception &#123;</span><br><span class="line"> </span><br><span class="line">    QrLoginToken qrLoginToken = new QrLoginToken();</span><br><span class="line">    qrLoginToken.setToken(token);</span><br><span class="line">    qrLoginToken = qrLoginTokenMapper.selectOne(qrLoginToken);</span><br><span class="line"> </span><br><span class="line">    if(null == qrLoginToken)&#123;</span><br><span class="line">        throw  new Exception(&quot;错误的请求！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    Date createDate = new Date(qrLoginToken.getCreateTime().getTime() + (1000 * 60 * Constant.LOGIN_VALIDATION_TIME));</span><br><span class="line">    Date nowDate = new Date();</span><br><span class="line">    if(nowDate.getTime() &gt; createDate.getTime())&#123;//当前时间大于校验时间</span><br><span class="line"> </span><br><span class="line">        JSONObject jsonObject = new JSONObject();</span><br><span class="line">        jsonObject.put(&quot;code&quot;,500);</span><br><span class="line">        jsonObject.put(&quot;msg&quot;,&quot;二维码失效！&quot;);</span><br><span class="line">        WebSocketServer.sendInfo(jsonObject.toJSONString(),token);</span><br><span class="line"> </span><br><span class="line">        throw  new Exception(&quot;二维码失效！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    qrLoginToken.setLoginTime(new Date());</span><br><span class="line">    qrLoginToken.setUserId(userId);</span><br><span class="line"> </span><br><span class="line">    int i = qrLoginTokenMapper.updateById(qrLoginToken);</span><br><span class="line"> </span><br><span class="line">    JSONObject jsonObject = new JSONObject();</span><br><span class="line">    jsonObject.put(&quot;code&quot;,200);</span><br><span class="line">    jsonObject.put(&quot;msg&quot;,&quot;ok&quot;);</span><br><span class="line">    jsonObject.put(&quot;userId&quot;,userId);</span><br><span class="line">    if(ToolUtil.isNotEmpty(projId))&#123;</span><br><span class="line">        jsonObject.put(&quot;projId&quot;,projId);</span><br><span class="line">    &#125;</span><br><span class="line">    WebSocketServer.sendInfo(jsonObject.toJSONString(),token);</span><br><span class="line"> </span><br><span class="line">    if(i &gt; 0 )&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        throw  new Exception(&quot;服务器异常！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑大概就是判断一下 token对不对。</p><p>如果对的话。时间是否过期。如果没有过期进行业务逻辑操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//这句话比较关键</span><br><span class="line">WebSocketServer.sendInfo(jsonObject.toJSONString(),token);</span><br></pre></td></tr></table></figure><p>就是通知前端已经登录成功了。并且给他业务所需要的内容。</p><p>然后前端代码接收到了。就进行业务逻辑操作就可以啦。</p><p>————————————————<br>版权声明：本文为CSDN博主「93年颈椎病人」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/q826qq1878/article/details/91041679">https://blog.csdn.net/q826qq1878/article/details/91041679</a></p>]]></content>
      
      
      <categories>
          
          <category> WebSocket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 中 List 转 Map(Collectors.toMap) </title>
      <link href="//articles/2021/11/05/1636096023056.html"/>
      <url>//articles/2021/11/05/1636096023056.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用-Java8-特性"><a href="#使用-Java8-特性" class="headerlink" title="使用 Java8 特性"></a>使用 Java8 特性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userList.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br></pre></td></tr></table></figure><p>当然，如果希望得到 Map 的 value 为对象本身时，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userList.stream().collect(Collectors.toMap(User::getId, t -&gt; t));</span><br></pre></td></tr></table></figure><h3 id="关于-Collectors-toMap-方法"><a href="#关于-Collectors-toMap-方法" class="headerlink" title="关于 Collectors.toMap 方法"></a>关于 Collectors.toMap 方法</h3><p>Collectors.toMap 有三个重载方法：</p><p><img src="https://b3logfile.com/file/2021/11/image-f7a1db30.png" alt="image.png"></p><p><img src="https://b3logfile.com/file/2021/11/image-e1bd7184.png" alt="image.png"></p><p><img src="https://b3logfile.com/file/2021/11/image-499290b9.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper);</span><br><span class="line"></span><br><span class="line">toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper,</span><br><span class="line">        BinaryOperator&lt;U&gt; mergeFunction);</span><br><span class="line"></span><br><span class="line">toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper,</span><br><span class="line">        BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier);</span><br></pre></td></tr></table></figure><p>参数含义分别是：</p><ol><li>keyMapper：Key 的映射函数</li><li>valueMapper：Value 的映射函数</li><li>mergeFunction：当 Key 冲突时，调用的合并方法</li><li>mapSupplier：Map 构造器，在需要返回特定的 Map 时使用<br>如果 List 中 userId 有相同的，使用上面的写法会抛异常：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = Lists.newArrayList(</span><br><span class="line">        new User().setId(&quot;A&quot;).setName(&quot;张三&quot;),</span><br><span class="line">        new User().setId(&quot;A&quot;).setName(&quot;李四&quot;), // Key 相同 </span><br><span class="line">        new User().setId(&quot;C&quot;).setName(&quot;王五&quot;)</span><br><span class="line">);</span><br><span class="line">userList.stream().collect(Collectors.toMap(User::getId, User::getName));</span><br></pre></td></tr></table></figure><p><strong>异常</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: Duplicate key A</span><br></pre></td></tr></table></figure><p>这时就需要调用第二个重载方法，传入合并函数，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userList.stream().collect(Collectors.toMap(User::getId, User::getName, (n1, n2) -&gt; n1 + n2));</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A-&gt; 张三李四 </span><br><span class="line">C-&gt; 王五</span><br></pre></td></tr></table></figure><p>第四个参数（mapSupplier）用于自定义返回 Map 类型，比如我们希望返回的 Map 是根据 Key 排序的，可以使用如下写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; userList = Lists.newArrayList(</span><br><span class="line">        new User().setId(&quot;B&quot;).setName(&quot;张三&quot;),</span><br><span class="line">        new User().setId(&quot;A&quot;).setName(&quot;李四&quot;),</span><br><span class="line">        new User().setId(&quot;C&quot;).setName(&quot;王五&quot;)</span><br><span class="line">);</span><br><span class="line">userList.stream().collect(</span><br><span class="line">    Collectors.toMap(User::getId, User::getName, (n1, n2) -&gt; n1, TreeMap::new)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A-&gt; 李四</span><br><span class="line">B-&gt; 张三</span><br><span class="line">C-&gt; 王五</span><br></pre></td></tr></table></figure><h3 id="Collectors-类的静态工厂方法"><a href="#Collectors-类的静态工厂方法" class="headerlink" title="Collectors 类的静态工厂方法"></a>Collectors 类的静态工厂方法</h3><table><thead><tr><th>方法</th><th>返回类型</th><th>作用</th></tr></thead><tbody><tr><td>toList</td><td><code>List&lt; T &gt;</code></td><td>把流中所有项目收集到一个 List</td></tr><tr><td>toSet</td><td><code>Set&lt; T &gt;</code></td><td>把流中所有项目收集到一个 Set，删除重复项</td></tr><tr><td>toCollection</td><td><code>Collection&lt; T &gt;</code></td><td>把流中所有项目收集到给定的供应源创建的集合<code>menuStream.collect(toCollection(), ArrayList::new)</code></td></tr><tr><td>counting</td><td>Long</td><td>计算流中元素的个数</td></tr><tr><td>sumInt</td><td>Integer</td><td>对流中项目的一个整数属性求和</td></tr><tr><td>averagingInt</td><td>Double</td><td>计算流中项目 Integer 属性的平均值</td></tr><tr><td>summarizingInt</td><td>IntSummaryStatistics</td><td>收集关于流中项目 Integer 属性的统计值，例如最大、最小、 总和与平均值</td></tr><tr><td>joining</td><td>String</td><td>连接对流中每个项目调用 toString 方法所生成的字符串<code>collect(joining(&quot;, &quot;))</code></td></tr><tr><td>maxBy</td><td><code>Optional&lt; T &gt;</code></td><td>一个包裹了流中按照给定比较器选出的最大元素的 Optional， 或如果流为空则为 Optional.empty()</td></tr><tr><td>minBy</td><td><code>Optional&lt; T &gt;</code></td><td>一个包裹了流中按照给定比较器选出的最小元素的 Optional， 或如果流为空则为 Optional.empty()</td></tr><tr><td>reducing</td><td>归约操作产生的类型</td><td>从一个作为累加器的初始值开始，利用 BinaryOperator 与流 中的元素逐个结合，从而将流归约为单个值累加int totalCalories &#x3D; menuStream.collect(reducing(0, Dish::getCalories, Integer::sum));</td></tr><tr><td>collectingAndThen</td><td>转换函数返回的类型</td><td>包裹另一个收集器，对其结果应用转换函数<code>int howManyDishes = menuStream.collect(collectingAndThen(toList(), List::size))</code></td></tr><tr><td>groupingBy</td><td><code>Map&lt; K,List&lt; T &gt; &gt;</code></td><td>根据项目的一个属性的值对流中的项目作问组，并将属性值作 为结果 Map 的键</td></tr><tr><td>partitioningBy</td><td><code>Map&lt; Boolean , List&lt; T &gt;&gt;</code></td><td>根据对流中每个项目应用谓词的结果来对项目进行分区</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池之ThreadPoolExecutor</title>
      <link href="//articles/2021/08/20/1629456511927.html"/>
      <url>//articles/2021/08/20/1629456511927.html</url>
      
        <content type="html"><![CDATA[<p>ThreadPoolExecutor提供了四个构造方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">                              int maximumPoolSize,</span><br><span class="line">                              long keepAliveTime,</span><br><span class="line">                              TimeUnit unit,</span><br><span class="line">                              BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">                              ThreadFactory threadFactory,</span><br><span class="line">                              RejectedExecutionHandler handler) &#123;</span><br><span class="line">        if (corePoolSize &lt; 0 ||</span><br><span class="line">            maximumPoolSize &lt;= 0 ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; 0)</span><br><span class="line">            throw new IllegalArgumentException();</span><br><span class="line">        if (workQueue == null || threadFactory == null || handler == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        this.corePoolSize = corePoolSize;</span><br><span class="line">        this.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        this.workQueue = workQueue;</span><br><span class="line">        this.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        this.threadFactory = threadFactory;</span><br><span class="line">        this.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><table><thead><tr><th>序号</th><th>名称</th><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>corePoolSize</td><td>int</td><td>核心线程池大小</td></tr><tr><td>2</td><td>maximumPoolSize</td><td>int</td><td>最大线程池大小</td></tr><tr><td>3</td><td>keepAliveTime</td><td>long</td><td>线程最大空闲时间</td></tr><tr><td>4</td><td>unit</td><td>TimeUnit</td><td>时间单位</td></tr><tr><td>5</td><td>workQueue</td><td>BlockingQueue</td><td>线程等待队列</td></tr><tr><td>6</td><td>threadFactory</td><td>ThreadFactory</td><td>线程创建工厂</td></tr><tr><td>7</td><td>handler</td><td>RejectedExecutionHandler</td><td>拒绝策略</td></tr></tbody></table><h4 id="线程池的构建"><a href="#线程池的构建" class="headerlink" title="线程池的构建"></a>线程池的构建</h4><h5 id="一、预定义线程池"><a href="#一、预定义线程池" class="headerlink" title="一、预定义线程池"></a>一、预定义线程池</h5><ol><li><strong>FixedThreadPool</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个固定大小的线程池，是其优势；</li><li>keepAliveTime &#x3D; 0 该参数默认对核心线程无效，而FixedThreadPool全部为核心线程；</li><li>workQueue 为LinkedBlockingQueue（无界阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；</li><li>FixedThreadPool的任务执行是无序的；</li></ul></blockquote><p>适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。</p><ol start="2"><li><strong>CachedThreadPool</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>corePoolSize &#x3D; 0，maximumPoolSize &#x3D; Integer.MAX_VALUE，即线程数量几乎无限制；</li><li>keepAliveTime &#x3D; 60s，线程空闲60s后自动结束。</li><li>workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须同时传递，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；</li></ul></blockquote><p>适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。</p><ol start="3"><li><strong>SingleThreadExecutor</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>咋一瞅，不就是newFixedThreadPool(1)吗？定眼一看，这里多了一层FinalizableDelegatedExecutorService包装，这一层有什么用呢，写个dome来解释一下：</p><p>**</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">fixedExecutorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> (ThreadPoolExecutor) fixedExecutorService;</span><br><span class="line">        System.out.println(threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(<span class="number">8</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">singleExecutorService</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//      运行时异常 java.lang.ClassCastException</span></span><br><span class="line"><span class="comment">//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。<strong>因此，SingleThreadExecutor被定以后，无法修改，做到了真正的Single。</strong></p><ol start="4"><li><strong>ScheduledThreadPool</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title function_">newScheduledThreadPool</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>newScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ScheduledThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">DelayedWorkQueue</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于ScheduledThreadPool本文不做描述，其特性请关注后续篇章。</p><h5 id="二、自定义线程池"><a href="#二、自定义线程池" class="headerlink" title="二、自定义线程池"></a>二、自定义线程池</h5><p>以下是自定义线程池，使用了有界队列，自定义ThreadFactory和拒绝策略的demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">corePoolSize</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maximumPoolSize</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">keepAliveTime</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">TimeUnit</span> <span class="variable">unit</span> <span class="operator">=</span> TimeUnit.SECONDS;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ThreadFactory</span> <span class="variable">threadFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NameTreadFactory</span>();</span><br><span class="line">        <span class="type">RejectedExecutionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyIgnorePolicy</span>();</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit,</span><br><span class="line">                workQueue, threadFactory, handler);</span><br><span class="line">        executor.prestartAllCoreThreads(); <span class="comment">// 预启动所有核心线程</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">MyTask</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTask</span>(String.valueOf(i));</span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.in.read(); <span class="comment">//阻塞主线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">NameTreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">mThreadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r, <span class="string">&quot;my-thread-&quot;</span> + mThreadNum.getAndIncrement());</span><br><span class="line">            System.out.println(t.getName() + <span class="string">&quot; has been created&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyIgnorePolicy</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            doLog(r, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doLog</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> &#123;</span><br><span class="line">            <span class="comment">// 可做日志记录等</span></span><br><span class="line">            System.err.println( r.toString() + <span class="string">&quot; rejected&quot;</span>);</span><br><span class="line"><span class="comment">//          System.out.println(&quot;completedTaskCount: &quot; + e.getCompletedTaskCount());</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="built_in">this</span>.toString() + <span class="string">&quot; is running!&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>); <span class="comment">//让任务执行慢点</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;MyTask [name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="https://b3logfile.com/file/2021/08/image-2137e249.png" alt="image.png"></p><ol><li>由于线程预启动，首先创建了1，2号线程，然后task1，task2被执行；</li><li>但任务提交没有结束，此时任务task3，task6到达发现核心线程已经满了，进入等待队列；</li><li>等待队列满后创建任务线程3，4执行任务task3，task6，同时task4，task5进入队列；</li><li>此时创建线程数（4）等于最大线程数，且队列已满，所以7，8，9，10任务被拒绝；</li><li>任务执行完毕后回头来执行task4，task5，队列清空。</li></ol><h4 id="总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。"><a href="#总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。" class="headerlink" title="总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。"></a>总结，通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。</h4>]]></content>
      
      
      <categories>
          
          <category> 线程池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JUC </tag>
            
            <tag> 线程池 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高并发之查询并更新原子问题</title>
      <link href="//articles/2021/08/20/1629450256915.html"/>
      <url>//articles/2021/08/20/1629450256915.html</url>
      
        <content type="html"><![CDATA[<h1 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h1><p>在日常开发中经常遇到先根据条件判断某条数据是否存在，如果不存在的话就插入，如果存在的话就更新或提示异常。一般代码的模式都写成下面这个样子，是一种很常见的写法，但是在并发情况下很容易会重复插入两条数据，大概的情况就是第一个请求进来，没有查询到该用户通过了<code>if</code>判断，但是<code>if</code>中有比较耗时的逻辑，在第一个请求还没执行<code>insert</code>的时候第二个请求也进来了，因为这个时候第一个请求还没执行<code>insert</code>操作，所以第二个请求也没有查询到该用户也通过了<code>if</code>判断，这个样子就造成了两条重复的数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 查询名字叫user1的用户是否存在</span><br><span class="line">UserVo userVo= userMapper.selectUserByName(&quot;user1&quot;);</span><br><span class="line">    // 如果不存在就插入数据</span><br><span class="line">    if (userVo==null) &#123;</span><br><span class="line">        Thread.sleep(10000);</span><br><span class="line">        UserVo userVo = new UserVo();</span><br><span class="line">        userVo.setUserName(&quot;user1&quot;);</span><br><span class="line">        userMapper.insert(userVo);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h1><h4 id="1-使用synchronized同步代码块"><a href="#1-使用synchronized同步代码块" class="headerlink" title="1. 使用synchronized同步代码块"></a>1. 使用<code>synchronized</code>同步代码块</h4><p>直接将查询校验逻辑和插入逻辑都进行同步，也就是说第一个请求的逻辑没结束，第二个请求就会一直等待着，只有当第一个请求执行完同步代码块中的逻辑释放锁后第二个请求才能获取到锁执行这段逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private Object obj = new Object();</span><br><span class="line"></span><br><span class="line">synchronized (object)&#123;</span><br><span class="line">    // 查询名字叫user1的用户是否存在</span><br><span class="line">    UserVo userVo= userMapper.selectUserByName(&quot;user1&quot;);</span><br><span class="line">    // 如果不存在就插入数据</span><br><span class="line">    if (userVo==null) &#123;</span><br><span class="line">        Thread.sleep(10000);</span><br><span class="line">        UserVo userVo = new UserVo();</span><br><span class="line">        userVo.setUserName(&quot;user1&quot;);</span><br><span class="line">        userMapper.insert(userVo);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-使用Lock锁"><a href="#2-使用Lock锁" class="headerlink" title="2.使用Lock锁"></a>2.使用<code>Lock</code>锁</h4><p>其实和<code>synchronized</code>代码块是相同的作用，但是要注意必须在<code>finally</code>中释放锁，避免出现异常死锁了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Lock lock = new ReentrantLock();</span><br><span class="line">try &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    // 查询名字叫user1的用户是否存在</span><br><span class="line">    UserVo userVo = userMapper.selectUserByName(&quot;user1&quot;);</span><br><span class="line">    // 如果不存在就插入数据</span><br><span class="line">    if (userVo == null) &#123;</span><br><span class="line">        Thread.sleep(10000);</span><br><span class="line">        UserVo userVo = new UserVo();</span><br><span class="line">        userVo.setUserName(&quot;user1&quot;);</span><br><span class="line">        userMapper.insert(userVo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-给数据库索引"><a href="#3-给数据库索引" class="headerlink" title="3.给数据库索引"></a>3.给数据库索引</h4><p>既然是要根据用户名字判断是否有重复数据，所以可以直接在数据库上给<code>userName</code>字段添加<code>UNIQUE</code>索引，这样在第二次重复插入的时候就会提示异常。如果不想重复插入的时候有报错提示可以使用<code>INSERT IGNORE INTO</code>语句。而代码则不必做任何逻辑操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 查询名字叫user1的用户是否存在</span><br><span class="line">UserVo userVo= userMapper.selectUserByName(&quot;user1&quot;);</span><br><span class="line">// 如果不存在就插入数据</span><br><span class="line">if (userVo==null) &#123;</span><br><span class="line">    Thread.sleep(10000);</span><br><span class="line">    UserVo userVo = new UserVo();</span><br><span class="line">    userVo.setUserName(&quot;user1&quot;);</span><br><span class="line">    userMapper.insert(userVo);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-使用redis中setnx来作为锁"><a href="#4-使用redis中setnx来作为锁" class="headerlink" title="4.使用redis中setnx来作为锁"></a>4.使用<code>redis</code>中<code>setnx</code>来作为锁</h4><p><code>redis</code>中<code>setnx</code>命令是只有当你存入的<code>key</code>不存在时才会成功存入，并返回1，而如果<code>key</code>已经存在的时候则存入失败并返回0，我们可以拿这个特性来当做锁。首先这个方法进来第一步就是执行<code>setnx</code>操作，把查询的用户名存入<code>redis</code>，然后查询该用户是否存在，第一个请求进到<code>if</code>判断中但是没执行插入逻辑，第二个请求虽然也没有查询到该用户，但是它的<code>setnx</code>会失败，因为第一个请求存的<code>key</code>还没删除，所以这样就避免了并发重新插入的问题，而且最大的优点就是它不像<code>synchronized</code>和<code>Lock</code>无论所有请求进来都只能一个一个通过，使用这种方法是只有当操作同一个用户有并发请求的时候才会阻塞，而如果是请求两个不同的用户时是不会阻塞的，都可以顺利通过，因为存入的<code>key</code>是不同的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 自动注入spring的redis操作类</span><br><span class="line">@Autowired</span><br><span class="line">private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">public String addUser (String userName) &#123;</span><br><span class="line">    // 执行setnx命令，存入当前拿来判断的用户名</span><br><span class="line">    BoundValueOperations operations = redisTemplate.boundValueOps(userName);</span><br><span class="line">    // 执行setnx命令的结果，这里封装的方法是直接返回true和false</span><br><span class="line">    boolean addFlag = operations.setIfAbsent(1);</span><br><span class="line"></span><br><span class="line">    // 返回结果</span><br><span class="line">    String result = null;</span><br><span class="line">    </span><br><span class="line">    UserVo userVo= userMapper.selectUserByName(userName);</span><br><span class="line">    try &#123;</span><br><span class="line">        if (userVo == null &amp;&amp; addFlag == true) &#123;</span><br><span class="line">            Thread.sleep(10000);</span><br><span class="line">            UserVo userVo = new UserVo();</span><br><span class="line">            userVo.setUserName(&quot;user1&quot;);</span><br><span class="line">            userMapper.insert(userVo);</span><br><span class="line">            result = &quot;更新成功&quot;;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            result = &quot;更新失败&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        // 无论更新成功和失败都去删除setnx添加的key</span><br><span class="line">        operations.getOperations().delete(userName);</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>上述四种方法，给数据库加索引、<code>Lock</code>和<code>redis</code>都有使用过，<code>synchronized</code>和<code>Lock</code>也差不多，个人感觉给数据库加索引来控制这种并发太死板了，万一系统中有其他地方的逻辑是需要重复添加这个字段的数据，这个时候就没办法使用索引了，<code>synchronized</code>和<code>Lock</code>效率太低了，如果是并发量太大的这种方式肯定是不可缺的，而redis的这种方法则效率高很多，比较适合并发量高的操作。</p>]]></content>
      
      
      <categories>
          
          <category> 高并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 原子 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>架构—秒杀系统优化思路</title>
      <link href="//articles/2021/07/09/1625814815830.html"/>
      <url>//articles/2021/07/09/1625814815830.html</url>
      
        <content type="html"><![CDATA[<h1 id="秒杀系统优化思路"><a href="#秒杀系统优化思路" class="headerlink" title="秒杀系统优化思路"></a>秒杀系统优化思路</h1><blockquote><p>转载：<a href="https://www.w3cschool.cn/architectroad/architectroad-optimization-of-seckilling-system.html">架构之师</a></p></blockquote><h2 id="一、秒杀业务为什么难做"><a href="#一、秒杀业务为什么难做" class="headerlink" title="一、秒杀业务为什么难做"></a>一、秒杀业务为什么难做</h2><ol><li>im系统，例如qq或者微博，每个人都读自己的数据（好友列表、群列表、个人信息）；</li><li>微博系统，每个人读你关注的人的数据，一个人读多个人的数据；</li><li>秒杀系统，库存只有一份，所有人会在集中的时间读和写这些数据，多个人读一个数据。</li></ol><p>例如：小米手机每周二的秒杀，可能手机只有1万部，但瞬时进入的流量可能是几百几千万。<br>又例如：12306抢票，票是有限的，库存一份，瞬时流量非常多，都读相同的库存。读写冲突，锁非常严重，这是秒杀业务难的地方。那我们怎么优化秒杀业务的架构呢？</p><h2 id="二、优化方向"><a href="#二、优化方向" class="headerlink" title="二、优化方向"></a>二、优化方向</h2><p>优化方向有两个（今天就讲这两个点）：<br>（1）将请求尽量拦截在系统上游（不要让锁冲突落到数据库上去）。传统秒杀系统之所以挂，请求都压倒了后端数据层，数据读写锁冲突严重，并发高响应慢，几乎所有请求都超时，流量虽大，下单成功的有效流量甚小。以12306为例，一趟火车其实只有2000张票，200w个人来买，基本没有人能买成功，请求有效率为0。</p><p>（2）充分利用缓存，秒杀买票，这是一个典型的读多写少的应用场景，大部分请求是车次查询，票查询，下单和支付才是写请求。一趟火车其实只有2000张票，200w个人来买，最多2000个人下单成功，其他人都是查询库存，写比例只有0.1%，读比例占99.9%，非常适合使用缓存来优化。好，后续讲讲怎么个“将请求尽量拦截在系统上游”法，以及怎么个“缓存”法，讲讲细节。</p><h2 id="三、常见秒杀架构"><a href="#三、常见秒杀架构" class="headerlink" title="三、常见秒杀架构"></a>三、常见秒杀架构</h2><p>常见的站点架构基本是这样的（绝对不画忽悠类的架构图）</p><p><img src="https://b3logfile.com/file/2021/07/image-fe42d21d.png" alt="image.png"></p><p>秒杀架构</p><ul><li>浏览器端，最上层，会执行到一些JS代码</li><li>站点层，这一层会访问后端数据，拼html页面返回给浏览器</li><li>服务层，向上游屏蔽底层数据细节，提供数据访问</li><li>数据层，最终的库存是存在这里的，mysql是一个典型（当然还有会缓存）</li></ul><p>这个图虽然简单，但能形象的说明大流量高并发的秒杀业务架构，大家要记得这一张图。后面细细解析各个层级怎么优化。</p><h2 id="四、各层次优化细节"><a href="#四、各层次优化细节" class="headerlink" title="四、各层次优化细节"></a>四、各层次优化细节</h2><h3 id="第一层，客户端怎么优化（浏览器层，APP层）"><a href="#第一层，客户端怎么优化（浏览器层，APP层）" class="headerlink" title="第一层，客户端怎么优化（浏览器层，APP层）"></a>第一层，客户端怎么优化（浏览器层，APP层）</h3><p>问大家一个问题，大家都玩过微信的摇一摇抢红包对吧，每次摇一摇，就会往后端发送请求么？回顾我们下单抢票的场景，点击了“查询”按钮之后，系统那个卡呀，进度条涨的慢呀，作为用户，我会不自觉的再去点击“查询”，对么？继续点，继续点，点点点。。。有用么？平白无故的增加了系统负载，一个用户点5次，80%的请求是这么多出来的，怎么整？</p><ol><li>产品层面，用户点击“查询”或者“购票”后，按钮置灰，禁止用户重复提交请求；</li><li>JS层面，限制用户在x秒之内只能提交一次请求；</li></ol><p>APP层面，可以做类似的事情，虽然你疯狂的在摇微信，其实x秒才向后端发起一次请求。这就是所谓的“将请求尽量拦截在系统上游”，越上游越好，浏览器层，APP层就给拦住，这样就能挡住80%+的请求，这种办法只能拦住普通用户（但99%的用户是普通用户）对于群内的高端程序员是拦不住的。firebug一抓包，http长啥样都知道，js是万万拦不住程序员写for循环，调用http接口的，这部分请求怎么处理？</p><h3 id="第二层，站点层面的请求拦截"><a href="#第二层，站点层面的请求拦截" class="headerlink" title="第二层，站点层面的请求拦截"></a>第二层，站点层面的请求拦截</h3><p>怎么拦截？怎么防止程序员写for循环调用，有去重依据么？ip？cookie-id？…想复杂了，这类业务都需要登录，用uid即可。在站点层面，对uid进行请求计数和去重，甚至不需要统一存储计数，直接站点层内存存储（这样计数会不准，但最简单）。一个uid，5秒只准透过1个请求，这样又能拦住99%的for循环请求。</p><p>5s只透过一个请求，其余的请求怎么办？缓存，页面缓存，同一个uid，限制访问频度，做页面缓存，x秒内到达站点层的请求，均返回同一页面。同一个item的查询，例如车次，做页面缓存，x秒内到达站点层的请求，均返回同一页面。如此限流，既能保证用户有良好的用户体验（没有返回404）又能保证系统的健壮性（利用页面缓存，把请求拦截在站点层了）。</p><p>页面缓存不一定要保证所有站点返回一致的页面，直接放在每个站点的内存也是可以的。优点是简单，坏处是http请求落到不同的站点，返回的车票数据可能不一样，这是站点层的请求拦截与缓存优化。</p><p>好，这个方式拦住了写for循环发http请求的程序员，有些高端程序员（黑客）控制了10w个肉鸡，手里有10w个uid，同时发请求（先不考虑实名制的问题，小米抢手机不需要实名制），这下怎么办，站点层按照uid限流拦不住了。</p><h3 id="第三层-服务层来拦截（反正就是不要让请求落到数据库上去）"><a href="#第三层-服务层来拦截（反正就是不要让请求落到数据库上去）" class="headerlink" title="第三层 服务层来拦截（反正就是不要让请求落到数据库上去）"></a>第三层 服务层来拦截（反正就是不要让请求落到数据库上去）</h3><p>服务层怎么拦截？大哥，我是服务层，我清楚的知道小米只有1万部手机，我清楚的知道一列火车只有2000张车票，我透10w个请求去数据库有什么意义呢？没错，请求队列！</p><p>对于写请求，做请求队列，每次只透有限的写请求去数据层（下订单，支付这样的写业务）</p><p>1w部手机，只透1w个下单请求去db</p><p>3k张火车票，只透3k个下单请求去db</p><p>如果均成功再放下一批，如果库存不够则队列里的写请求全部返回“已售完”。</p><p>对于读请求，怎么优化？cache抗，不管是memcached还是redis，单机抗个每秒10w应该都是没什么问题的。如此限流，只有非常少的写请求，和非常少的读缓存mis的请求会透到数据层去，又有99.9%的请求被拦住了。</p><p>当然，还有业务规则上的一些优化。回想12306所做的，分时分段售票，原来统一10点卖票，现在8点，8点半，9点，…每隔半个小时放出一批：将流量摊匀。</p><p>其次，数据粒度的优化：你去购票，对于余票查询这个业务，票剩了58张，还是26张，你真的关注么，其实我们只关心有票和无票？流量大的时候，做一个粗粒度的“有票”“无票”缓存即可。</p><p>第三，一些业务逻辑的异步：例如下单业务与 支付业务的分离。这些优化都是结合 业务 来的，我之前分享过一个观点“一切脱离业务的架构设计都是耍流氓”架构的优化也要针对业务。</p><h3 id="第四层-最后是数据库层"><a href="#第四层-最后是数据库层" class="headerlink" title="第四层 最后是数据库层"></a>第四层 最后是数据库层</h3><p>浏览器拦截了80%，站点层拦截了99.9%并做了页面缓存，服务层又做了写请求队列与数据缓存，每次透到数据库层的请求都是可控的。db基本就没什么压力了，闲庭信步，单机也能扛得住，还是那句话，库存是有限的，小米的产能有限，透这么多请求来数据库没有意义。</p><p>全部透到数据库，100w个下单，0个成功，请求有效率0%。透3k个到数据，全部成功，请求有效率100%。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>上文应该描述的非常清楚了，没什么总结了，对于秒杀系统，再次重复下我个人经验的两个架构优化思路：</p><ol><li>尽量将请求拦截在系统上游（越上游越好）；</li><li>读多写少的常用多使用缓存（缓存抗读压力）；</li></ol><p>浏览器和APP：做限速</p><p>站点层：按照uid做限速，做页面缓存</p><p>服务层：按照业务做写请求队列控制流量，做数据缓存</p><p>数据层：闲庭信步</p><p>并且：结合业务做优化</p><h2 id="六、Q-A"><a href="#六、Q-A" class="headerlink" title="六、Q&amp;A"></a>六、Q&amp;A</h2><p><strong>问题1</strong>、按你的架构，其实压力最大的反而是站点层，假设真实有效的请求数有1000万，不太可能限制请求连接数吧，那么这部分的压力怎么处理？</p><p><strong>答</strong>：每秒钟的并发可能没有1kw，假设有1kw，解决方案2个：</p><ol><li>站点层是可以通过加机器扩容的，最不济1k台机器来呗。</li><li>如果机器不够，抛弃请求，抛弃50%（50%直接返回稍后再试），原则是要保护系统，不能让所有用户都失败。</li></ol><p><strong>问题2</strong>、“控制了10w个肉鸡，手里有10w个uid，同时发请求” 这个问题怎么解决哈？</p><p><strong>答</strong>：上面说了，服务层写请求队列控制</p><p><strong>问题3</strong>：限制访问频次的缓存，是否也可以用于搜索？例如A用户搜索了“手机”，B用户搜索“手机”，优先使用A搜索后生成的缓存页面？</p><p><strong>答</strong>：这个是可以的，这个方法也经常用在“动态”运营活动页，例如短时间推送4kw用户app-push运营活动，做页面缓存。</p><p><strong>问题4</strong>：如果队列处理失败，如何处理？肉鸡把队列被撑爆了怎么办？</p><p><strong>答</strong>：处理失败返回下单失败，让用户再试。队列成本很低，爆了很难吧。最坏的情况下，缓存了若干请求之后，后续请求都直接返回“无票”（队列里已经有100w请求了，都等着，再接受请求也没有意义了）</p><p><strong>问题5</strong>：站点层过滤的话，是把uid请求数单独保存到各个站点的内存中么？如果是这样的话，怎么处理多台服务器集群经过负载均衡器将相同用户的响应分布到不同服务器的情况呢？还是说将站点层的过滤放到负载均衡前？</p><p><strong>答</strong>：可以放在内存，这样的话看似一台服务器限制了5s一个请求，全局来说（假设有10台机器），其实是限制了5s 10个请求，解决办法：</p><ol><li>加大限制（这是建议的方案，最简单）</li><li>在nginx层做7层均衡，让一个uid的请求尽量落到同一个机器上</li></ol><p><strong>问题6</strong>：服务层过滤的话，队列是服务层统一的一个队列？还是每个提供服务的服务器各一个队列？如果是统一的一个队列的话，需不需要在各个服务器提交的请求入队列前进行锁控制？</p><p><strong>答</strong>：可以不用统一一个队列，这样的话每个服务透过更少量的请求（总票数&#x2F;服务个数），这样简单。统一一个队列又复杂了。</p><p><strong>问题7</strong>：秒杀之后的支付完成，以及未支付取消占位，如何对剩余库存做及时的控制更新？</p><p><strong>答</strong>：数据库里一个状态，未支付。如果超过时间，例如45分钟，库存会重新会恢复（大家熟知的“回仓”），给我们抢票的启示是，开动秒杀后，45分钟之后再试试看，说不定又有票哟~</p><p><strong>问题8</strong>：不同的用户浏览同一个商品 落在不同的缓存实例显示的库存完全不一样 请问老师怎么做缓存数据一致或者是允许脏读？</p><p><strong>答</strong>：目前的架构设计，请求落到不同的站点上，数据可能不一致（页面缓存不一样），这个业务场景能接受。但数据库层面真实数据是没问题的。</p><p><strong>问题9</strong>：就算处于业务把优化考虑“3k张火车票，只透3k个下单请求去db”那这3K个订单就不会发生拥堵了吗？</p><p><strong>答</strong>：</p><ol><li>数据库抗3k个写请求还是ok的；</li><li>可以数据拆分；</li><li>如果3k扛不住，服务层可以控制透过去的并发数量，根据压测情况来吧，3k只是举例；</li></ol><p><strong>问题10</strong>、如果在站点层或者服务层处理后台失败的话，需不需要考虑对这批处理失败的请求做重放？还是就直接丢弃？</p><p><strong>答</strong>：别重放了，返回用户查询失败或者下单失败吧，架构设计原则之一是“fail fast”。</p><p><strong>问题11</strong>、对于大型系统的秒杀，比如12306，同时进行的秒杀活动很多，如何分流？</p><p><strong>答</strong>：垂直拆分</p><p><strong>问题12</strong>、额外又想到一个问题。这套流程做成同步还是异步的？如果是同步的话，应该还存在会有响应反馈慢的情况。但如果是异步的话，如何控制能够将响应结果返回正确的请求方？</p><p><strong>答</strong>：用户层面肯定是同步的（用户的http请求是夯住的），服务层面可以同步可以异步。</p><p><strong>问题13</strong>、秒杀群提问：减库存是在那个阶段减呢？如果是下单锁库存的话，大量恶意用户下单锁库存而不支付如何处理呢？</p><p><strong>答</strong>：数据库层面写请求量很低，还好，下单不支付，等时间过完再“回仓”，之前提过了。</p>]]></content>
      
      
      <categories>
          
          <category> 架构设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构涉及 </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中针对List集合(交集/并集/差集)和数组的Lambda操作</title>
      <link href="//articles/2020/12/07/1607345203030.html"/>
      <url>//articles/2020/12/07/1607345203030.html</url>
      
        <content type="html"><![CDATA[<h2 id="Lambda实现Java-List的交集-并集-差集-去重复并集"><a href="#Lambda实现Java-List的交集-并集-差集-去重复并集" class="headerlink" title="Lambda实现Java List的交集&#x2F;并集&#x2F;差集&#x2F;去重复并集"></a>Lambda实现Java List的交集&#x2F;并集&#x2F;差集&#x2F;去重复并集</h2><blockquote><p>经常记不住，只能写下来了！！！</p></blockquote><ul><li>1.8之前交、并集采用简单的 removeAll retainAll 等操作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import static java.util.stream.Collectors.toList;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;String&gt; list1 = new ArrayList();</span><br><span class="line">        list1.add(&quot;1111&quot;);</span><br><span class="line">        list1.add(&quot;2222&quot;);</span><br><span class="line">        list1.add(&quot;3333&quot;);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list2 = new ArrayList();</span><br><span class="line">        list2.add(&quot;3333&quot;);</span><br><span class="line">        list2.add(&quot;4444&quot;);</span><br><span class="line">        list2.add(&quot;5555&quot;);</span><br><span class="line"></span><br><span class="line">        // 交集</span><br><span class="line">        List&lt;String&gt; intersection = list1.stream().filter(item -&gt; list2.contains(item)).collect(toList());</span><br><span class="line">        System.out.println(&quot;---得到交集 intersection---&quot;);</span><br><span class="line">        intersection.parallelStream().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">        // 差集 (list1 - list2)</span><br><span class="line">        List&lt;String&gt; reduce1 = list1.stream().filter(item -&gt; !list2.contains(item)).collect(toList());</span><br><span class="line">        System.out.println(&quot;---得到差集 reduce1 (list1 - list2)---&quot;);</span><br><span class="line">        reduce1.parallelStream().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">        // 差集 (list2 - list1)</span><br><span class="line">        List&lt;String&gt; reduce2 = list2.stream().filter(item -&gt; !list1.contains(item)).collect(toList());</span><br><span class="line">        System.out.println(&quot;---得到差集 reduce2 (list2 - list1)---&quot;);</span><br><span class="line">        reduce2.parallelStream().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">        // 并集</span><br><span class="line">        List&lt;String&gt; listAll = list1.parallelStream().collect(toList());</span><br><span class="line">        List&lt;String&gt; listAll2 = list2.parallelStream().collect(toList());</span><br><span class="line">        listAll.addAll(listAll2);</span><br><span class="line">        System.out.println(&quot;---得到并集 listAll---&quot;);</span><br><span class="line">        listAll.parallelStream().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">        // 去重并集</span><br><span class="line">        List&lt;String&gt; listAllDistinct = listAll.stream().distinct().collect(toList());</span><br><span class="line">        System.out.println(&quot;---得到去重并集 listAllDistinct---&quot;);</span><br><span class="line">        listAllDistinct.parallelStream().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;---原来的List1---&quot;);</span><br><span class="line">        list1.parallelStream().forEach(System.out :: println);</span><br><span class="line">        System.out.println(&quot;---原来的List2---&quot;);</span><br><span class="line">        list2.parallelStream().forEach(System.out :: println);</span><br><span class="line"></span><br><span class="line">// 一般有filter 操作时，不用并行流parallelStream ,如果用的话可能会导致线程安全问题</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream流之List、Integer-、int-相互转化"><a href="#Stream流之List、Integer-、int-相互转化" class="headerlink" title="Stream流之List、Integer[]、int[]相互转化"></a>Stream流之List、Integer[]、int[]相互转化</h2><ul><li>int[ ] 转 Integer[ ]</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = Arrays.stream(arr).boxed().toArray(Integer[]::new);</span><br></pre></td></tr></table></figure><ul><li><p>int[ ] 转 List&lt; Integer &gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  int[] arr = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">  List&lt;Integer&gt; list = Arrays.stream(arr).boxed().collect(Collectors.toList());</span><br><span class="line">  list.forEach(e -&gt; System.out.print(e + &quot; &quot;));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>Integer[ ]转 int[ ]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr= Arrays.stream(integers).mapToInt(Integer::valueOf).toArray();</span><br></pre></td></tr></table></figure></li><li><p>Integer[ ]转 List&lt; Integer &gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = &#123;1,2,3,4,5&#125;;</span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(integers);</span><br></pre></td></tr></table></figure></li><li><p>List&lt; Integer &gt; 转 Integer[ ]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] integers = list.toArray(new Integer[list.size()]);</span><br></pre></td></tr></table></figure></li><li><p>List&lt; Integer &gt; 转 int[ ]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int[] arr2 = list.stream().mapToInt(Integer::valueOf).toArray();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Lambda </tag>
            
            <tag> 数组 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud版本号</title>
      <link href="//articles/2020/08/20/1597909638127.html"/>
      <url>//articles/2020/08/20/1597909638127.html</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>Spring Cloud使用的版本号是英文方式，而不是传统的数字版本，为什么呢。因为Spring Cloud是微服务的解决方案，他会有很多子项目，每个子项目都维护这自己的版本号，为了避免冲突，就使用了伦敦地铁站的名字作为版本号。以首字母作为顺序，a,b,c,d….排列。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>现有版本号：Angel、Brixton、Camden、Daston、Edgware、Finchley、GreenWich、Hoxton。</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="常见版本号说明"><a href="#常见版本号说明" class="headerlink" title="常见版本号说明"></a>常见版本号说明</h4><blockquote><p>例如 2.1.13.RELEASE</p></blockquote><p>其中Release的意思是最终版本，除此之外：</p><ul><li><p>Base：设计阶段。只有相应的设计没有具体的功能实现。</p></li><li><p>Alpha：软件的初级版本。基本功能已经实现，但存在较多的bug。</p></li><li><p>Bate：相对于Alpha已经有了很大的进步，消除了严重的BUG，但还存在一些潜在的BUG，还需要不断测试。</p></li><li><p>RELEASE：最终版本，没有太大的问题。</p></li></ul><h4 id="Spring-Cloud-版本后缀"><a href="#Spring-Cloud-版本后缀" class="headerlink" title="Spring Cloud 版本后缀"></a>Spring Cloud 版本后缀</h4><ul><li>BUILD-XXX　　　　　开发版　　　　开发团队内部使用，不是很稳定</li><li>GA　　　　　　　　　稳定版　　　　相比于开发版，基本上可以使用了</li><li>PRE（M1、M2）　　  里程碑版　　　主要是修复了一些BUG的版本，一个GA后通常有多个里程碑版</li><li>RC　　　　　　　　　候选发布版　　该阶段的软件类似于最终版的一个发行观察期，基本只修复比较严重的BUG</li><li>SR　　　　　　　　    正式发布版</li></ul><p>　　</p><p>另外，springcloud和springboot的版本有相应的对应关系，如果不对应会出现问题。</p><p>具体关系可以查看：<a href="https://start.spring.io/info">https://start.spring.io/info</a></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> Java </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub 沙雕项目</title>
      <link href="//articles/2020/07/30/1596112525485.html"/>
      <url>//articles/2020/07/30/1596112525485.html</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><blockquote><p>今天推送几个沙雕项目，太秀了🤣 ，找几个过于沙雕的分享给大家。</p></blockquote><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="logoly"><a href="#logoly" class="headerlink" title="logoly"></a>logoly</h3><ul><li><strong>Star: 5.2k</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/bestony/logoly">https://github.com/bestony/logoly</a></li></ul><p>这个项目是一个简易的 logo 生成器，能生成下图类似风格的 logo。下图中关键部分做了马赛克处理 :trollface:</p><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-9813bf7f.png" alt="图片.png"></p><p>经常刷小破站的读者应该经常看到类似风格的视频封面，比如下图圈出来的封面。估计这种风格的封面是半佛老师的最爱呀～</p><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-6c82800f.png" alt="图片.png"></p><p>（不仅仅是B站，经常逛 P 站的朋友肯定见过这个风格的logo ）</p><p><strong>如何生成自己的 logo</strong></p><ul><li>打开Logoly网站：<a href="https://logoly.pro/">https://logoly.pro/</a></li><li>在框中编辑文本</li><li>根据需要更改颜色和字体大小</li><li>单击导出按钮以下载图像</li></ul><h3 id="Dress"><a href="#Dress" class="headerlink" title="Dress"></a>Dress</h3><ul><li><strong>Star: 17.7k</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/komeiji-satori/Dress">https://github.com/komeiji-satori/Dress</a></li></ul><p>你可能想不到这个 17.7k star 的项目是一个<strong>面向可爱的蓝孩子</strong>的 git 学习实践项目 。</p><p>该项目对贡献者的要求不高，并不要求你贡献代码，没有编程技能都可以参加。你可以从这里学习从克隆项目，创建分支，提交和同步修改，到合并分支请求的整套流程，一次即可熟悉 Git&#x2F;GitHub 的使用。</p><p>但是：<strong>你还要事先准备至少一张你的女装照。</strong></p><p>没错，这就是女装大佬集结地，截止目前为止，已经有 两百多名大佬上传过女装照，并且有 1103 次提交。光看贡献者的头像，二次元风格满满。本来想找几张给大家养养眼，打开后发现顶不住啊，溜了溜了。。。</p><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-d7814f29.png" alt="图片.png"></p><p>想在简历里写上：参与过Github 10000+ starts的项目，那你就PR这个吧</p><h3 id="灭霸脚本"><a href="#灭霸脚本" class="headerlink" title="灭霸脚本"></a>灭霸脚本</h3><ul><li><strong>Star : 2k</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/hotvulcan/Thanos.sh">https://github.com/hotvulcan/Thanos.sh</a></li></ul><p><img src="https://b3logfile.com/file/2020/07/solofetchupload2730086729904613691-66009904.jpeg"><br>一个开源的个灭霸命令，可随机删除电脑上一半文件</p><p><strong>PS</strong>：请不要在家里或其他地方使用。这是<strong>真家伙</strong>，要小心…</p><h3 id="wenyan"><a href="#wenyan" class="headerlink" title="wenyan"></a>wenyan</h3><ul><li><strong>Star: 16.2 k</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/wenyan-lang/wenyan">https://github.com/wenyan-lang/wenyan</a></li></ul><p>这是一个文言文編程語言，没错，文言文。。。你以为只是玩玩？你想多了，还有配套的 ide：<a href="https://ide.wy-lang.org/">https://ide.wy-lang.org/</a> 下图是一个快速排序的</p><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-499f2350.png" alt="图片.png"></p><p><strong>Helloworld</strong><br>Wenyan:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">吾有一數。曰三。名之曰「甲」。</span><br><span class="line">為是「甲」遍。</span><br><span class="line">吾有一言。曰「「問天地好在。」」。書之。</span><br><span class="line">云云。</span><br></pre></td></tr></table></figure><p>Equivalent JavaScript:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;問天地好在。&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">問天地好在。</span><br><span class="line">問天地好在。</span><br><span class="line">問天地好在。</span><br></pre></td></tr></table></figure><h3 id="dongbei"><a href="#dongbei" class="headerlink" title="dongbei"></a>dongbei</h3><ul><li><strong>Star: 1.4 k</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/zhanyong-wan/dongbei">https://github.com/zhanyong-wan/dongbei</a></li></ul><p>刚刚是文言文编程语言，这个是东北方言编程。体验一下东北方言编程的 hello word。</p><p><strong>吃了没，老铁</strong></p><p>创建一个名字叫 hello-world.dongbei 的文本文件，内容如下：</p><p><code>唠唠：“唉呀，这嘎哒真他妈那啥！”。</code></p><p>用 utf-8 编码保存。要是编辑器因为编码有毛病埋汰你，那就把文件内容改成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">唠唠：“唉呀，这嘎哒真他妈那啥！”。</span><br></pre></td></tr></table></figure><p>再试，应该就成了。</p><p>然后在命令行窗口运行：</p><p><code>dongbei hello-world.dongbei</code></p><p>你应该看到执行结果：</p><p><code>唉呀，这嘎哒真他妈那啥！</code></p><h3 id="一行代码没有"><a href="#一行代码没有" class="headerlink" title="一行代码没有"></a>一行代码没有</h3><ul><li><strong>Star 42.6k</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/kelseyhightower/nocode">https://github.com/kelseyhightower/nocode</a></li></ul><blockquote><p>项目理念：没有代码是编写安全可靠的应用程序的最佳方法。什么也不要写，也不用部署。</p></blockquote><p><strong>Hello Word：</strong></p><p><strong>入门</strong></p><p>首先不编写任何代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>这只是一个示例应用程序，但是请想象它可以做任何您想做的事情。添加新功能也很容易：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>一切皆有可能！</p><p><strong>构建应用程序</strong></p><p>现在您还没有做任何事情，现在是时候构建您的应用程序了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>您应该看到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><strong>部署</strong></p><p>尽管你没有做任何事情，但是现在该部署应用程序了。通过运行以下命令部署你的应用程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>就这么简单。当需要扩展应用程序时，你要做的就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>酷不酷？</p><p>这个项目啥都没有，就有 42.5k Star，而且 Issues 竟然也有 3.2k，集体装逼盛宴！翻了几页，大家体会一下：</p><ul><li>代码之源</li></ul><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-a8729f41.png" alt="图片.png"></p><ul><li>心中自然无码</li></ul><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-db9a35c7.png" alt="图片.png"></p><ul><li>无，即是万物</li></ul><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-da178c05.png" alt="图片.png"></p><ul><li>皇帝的新码</li></ul><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-bc2a5fe1.png" alt="图片.png"></p><h3 id="FakeScreenshot"><a href="#FakeScreenshot" class="headerlink" title="FakeScreenshot"></a>FakeScreenshot</h3><ul><li><strong>Star: 951</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/thegreatjavascript/FakeScreenshot">https://github.com/thegreatjavascript/FakeScreenshot</a></li></ul><blockquote></blockquote><blockquote><p>这是一个可以<strong>伪造任何网站界面截图</strong>的工具。</p><p>但本工具的目的其实不是破坏，而是为了警告（不懂编程的）普通人：<strong>不要轻易相信网上看到的“截图”！****2020-4-26：突破性更新</strong>，可以修改任何网站的任何文字&#x2F;图片。</p></blockquote><p><img src="https://github.com/thegreatjavascript/FakeScreenshot/raw/master/preview/basic.gif" alt="basic"><img src="https://github.com/thegreatjavascript/FakeScreenshot/raw/master/preview/dialog.gif" alt="basic"><img src="https://github.com/thegreatjavascript/FakeScreenshot/raw/master/preview/picture.gif" alt="basic"></p><p>很有意思的一个截图工具！！！</p><h3 id="seq2seq-couplet"><a href="#seq2seq-couplet" class="headerlink" title="seq2seq-couplet"></a>seq2seq-couplet</h3><ul><li><strong>Star 4.5k</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/wb14123/seq2seq-couplet">https://github.com/wb14123/seq2seq-couplet</a><br>一个有趣的对对联工具，用深度学习对对联</li></ul><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-cd5a9e7d.png" alt="图片.png"></p><p><a href="https://ai.binwang.me/couplet/">在线体验</a></p><h3 id="chinese-poetry"><a href="#chinese-poetry" class="headerlink" title="chinese-poetry"></a>chinese-poetry</h3><ul><li><strong>Star 29.5k</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/chinese-poetry/chinese-poetry">https://github.com/chinese-poetry/chinese-poetry</a></li></ul><blockquote><p>最全中华古诗词数据库, 唐宋两朝近一万四千古诗人, 接近5.5万首唐诗加26万宋诗. 两宋时期1564位词人，21050首词。</p></blockquote><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-b810d4ad.png" alt="图片.png"></p><p><a href="https://shici.store/huajianji/">浏览地址</a></p><h3 id="profile-summary-for-github"><a href="#profile-summary-for-github" class="headerlink" title="profile-summary-for-github"></a>profile-summary-for-github</h3><ul><li><strong>Star 19.1k</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/tipsy/profile-summary-for-github">https://github.com/tipsy/profile-summary-for-github</a></li></ul><blockquote><p>Tool for visualizing GitHub profiles(图像化展示Github账号的信息)</p></blockquote><p><img src="https://b3logfile.com/file/2020/07/solofetchupload3962234425586552932-7508cab1.png" alt="screenshot"></p><p><a href="https://profile-summary-for-github.com/">体验地址</a></p><p>PS：这个很Nice,可以再GitHub首页使用试试</p><h3 id="carbon"><a href="#carbon" class="headerlink" title="carbon"></a>carbon</h3><ul><li><strong>Star 24.8k</strong></li><li><strong>项目地址：</strong> <a href="https://github.com/carbon-app/carbon">https://github.com/carbon-app/carbon</a></li></ul><blockquote><p><strong>代码转换成图片</strong></p></blockquote><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-f8c392d3.png" alt="图片.png"></p><p>更多有趣项目：<a href="https://www.zhihu.com/question/23498424">https://www.zhihu.com/question/23498424</a></p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> 分享 </tag>
            
            <tag> GitHub </tag>
            
            <tag> 开源项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinIO-炒鸡好用的网盘+文件服务器</title>
      <link href="//articles/2020/07/24/1595578346772.html"/>
      <url>//articles/2020/07/24/1595578346772.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>MinIO 是一个基于Apache License v2.0开源协议的对象存储服务。它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器&#x2F;虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。<br>MinIO是一个非常轻量的服务,可以很简单的和其他应用的结合，类似 NodeJS, Redis 或者 MySQL</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>支持分布式存储，具备高扩展性、高可用性</li><li>部署简单但功能丰富 通过 <code>docker</code> 方式部署</li><li>官方的文档也很详细 <a href="https://docs.min.io/cn/"><code>MinIO</code></a></li><li>部署方式多样性(单机部署，分布式部署)</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>推荐使用 <code>docker</code> 一键安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -p 9000:9000 --name minio \</span><br><span class="line">-d --restart=always \</span><br><span class="line">-e &quot;MINIO_ACCESS_KEY=admin&quot; \</span><br><span class="line">-e &quot;MINIO_SECRET_KEY=12345678&quot; \</span><br><span class="line">-v /data/minio/data:/data \</span><br><span class="line">-v /data/minio/config:/root/.minio \</span><br><span class="line">minio/minio server /data</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>密钥必须大于8位，否则会创建失败</li><li>文件目录和配置文件一定要映射到主机</li></ul><h3 id="整合Nginx"><a href="#整合Nginx" class="headerlink" title="整合Nginx"></a>整合Nginx</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name minio.domain.com;</span><br><span class="line">    location /&#123;</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_pass http://localhost:9000;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ /\.ht &#123;</span><br><span class="line">        deny  all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过浏览器访问配置的地址，使用指定的 <code>MINIO_ACCESS_KEY</code> 及 <code>MINIO_SECRET_KEY</code> 登录即可</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote><p>界面简单，功能齐全，支持创建<code>Bucket</code>，文件上传、删除、分享、下载，同时可以对<code>Bucket</code>设置读写权限</p></blockquote><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-439ff84b.png" alt="图片.png"></p><h4 id="密码修改等"><a href="#密码修改等" class="headerlink" title="密码修改等"></a>密码修改等</h4><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-f358f9bf.png" alt="图片.png"></p><h4 id="Bucket设置读写权限"><a href="#Bucket设置读写权限" class="headerlink" title="Bucket设置读写权限"></a>Bucket设置读写权限</h4><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-b4dea89d.png" alt="图片.png"></p><h4 id="上传文件和创建Bucket"><a href="#上传文件和创建Bucket" class="headerlink" title="上传文件和创建Bucket"></a>上传文件和创建Bucket</h4><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-da9fcc85.png" alt="图片.png"></p><h4 id="文件分享等操作"><a href="#文件分享等操作" class="headerlink" title="文件分享等操作"></a>文件分享等操作</h4><p><img src="https://b3logfile.com/file/2020/07/%E5%9B%BE%E7%89%87-e9bbdb8d.png" alt="图片.png"></p>]]></content>
      
      
      <categories>
          
          <category> MinIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MinIO </tag>
            
            <tag> 文件服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EasyPoi导出字段为超链接</title>
      <link href="//articles/2020/06/17/1592396658708.html"/>
      <url>//articles/2020/06/17/1592396658708.html</url>
      
        <content type="html"><![CDATA[<h2 id="看文档-http-easypoi-mydoc-io"><a href="#看文档-http-easypoi-mydoc-io" class="headerlink" title="看文档 http://easypoi.mydoc.io/"></a>看文档 <a href="http://easypoi.mydoc.io/">http://easypoi.mydoc.io/</a></h2><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><ul><li>字段上面开启超链接<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Excel(name = &quot;地址&quot;, isHyperlink = true)</span><br><span class="line">private String path;</span><br></pre></td></tr></table></figure></li></ul><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><ul><li>实现拦截类</li></ul><p><img src="https://b3logfile.com/file/2020/06/image-921070d7.png" alt="image.png"></p><ul><li>代码实现</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ExcelDataHandler extends ExcelDataHandlerDefaultImpl&lt;Object&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Hyperlink getHyperlink(CreationHelper creationHelper, Object obj, String name, Object value) &#123;</span><br><span class="line">        Hyperlink hyperlink = creationHelper.createHyperlink(HyperlinkType.URL);</span><br><span class="line">        hyperlink.setLabel(name);</span><br><span class="line">        hyperlink.setAddress((String) value);</span><br><span class="line">        return hyperlink;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>Object</code>为操作类</p></blockquote><h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><ul><li>将拦截类加载导出方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExportParams exportParams = new ExportParams(title, sheetName);</span><br><span class="line">        exportParams.setDataHandler(new ExcelDataHandler());</span><br><span class="line">        ExportExcelUtil.exportExcel(list, Object.class, fileName, response, exportParams);</span><br></pre></td></tr></table></figure><blockquote><p><code>Object</code>操作模板</p></blockquote></li></ul><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3>]]></content>
      
      
      <categories>
          
          <category> EasyPOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> EasyPOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录IDEA的关于数据库连接问题</title>
      <link href="//articles/2020/06/10/1591791265043.html"/>
      <url>//articles/2020/06/10/1591791265043.html</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><pre><code>今天更新了IDEA，更新到2020.1.1，发现了两个关于数据库问题。</code></pre><h3 id="1-IDEA-数据库连接，密码不保存，重复输入问题"><a href="#1-IDEA-数据库连接，密码不保存，重复输入问题" class="headerlink" title="1. IDEA 数据库连接，密码不保存，重复输入问题"></a>1. IDEA 数据库连接，密码不保存，重复输入问题</h3><blockquote><p>明明是永远save，就是不起作用，每次重启IDEA都要输入。<br><img src="https://b3logfile.com/file/2020/06/image-8f3f9532.png" alt="image.png"></p></blockquote><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a>解答：</h4><p>在IDEA File—&gt;Setting—&gt;搜索In KeePass，然后勾选即可。</p><p><img src="https://b3logfile.com/file/2020/06/image-d86cc7bf.png" alt="image.png"></p><h3 id="2-IDEA-数据库连接上，mapper-xml文件中sql的表名和字段，不能点击问题"><a href="#2-IDEA-数据库连接上，mapper-xml文件中sql的表名和字段，不能点击问题" class="headerlink" title="2. IDEA 数据库连接上，mapper.xml文件中sql的表名和字段，不能点击问题"></a>2. IDEA 数据库连接上，mapper.xml文件中sql的表名和字段，不能点击问题</h3><h4 id="解答：-1"><a href="#解答：-1" class="headerlink" title="解答："></a>解答：</h4><ul><li>首先连接数据源</li><li>File-&gt;Settings-&gt;Languages&amp;Frameworks-&gt;SQL Resolution Scopes 勾选所有数据源<br> <img src="https://b3logfile.com/file/2020/06/image-323824e3.png" alt="image.png"></li><li>File-&gt;Settings-&gt;Languages&amp;Frameworks-&gt;SQL Dialects -&gt; 全局和项目选择MySQL<br>  <img src="https://b3logfile.com/file/2020/06/image-8542af4c.png" alt="image.png"></li></ul><h2 id="OK，解决！"><a href="#OK，解决！" class="headerlink" title="OK，解决！"></a>OK，解决！</h2>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> IDEA </tag>
            
            <tag> 数据库连接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Office 365的版本说明(A1/A1P/E3 MSDN/E3 Trial)以及常见问题</title>
      <link href="//articles/2020/05/29/1590746577309.html"/>
      <url>//articles/2020/05/29/1590746577309.html</url>
      
        <content type="html"><![CDATA[<p>本文介绍一下Office 365几个常见版本的区别！以及风险说明！希望对大家有所帮助！</p><h2 id="版本区别"><a href="#版本区别" class="headerlink" title="版本区别"></a>版本区别</h2><h3 id="Office365-A1"><a href="#Office365-A1" class="headerlink" title="Office365 A1"></a>Office365 A1</h3><p><strong>主要特征:</strong></p><pre><code>无Office365桌面版.无Azure Directory API操作权限.有管理员存在,才能在第三方应用挂载.有OneDrive for Busniess空间(1T~5T).正常情况下,许可证数量无限制(unlimited).</code></pre><p><strong>一些说明:</strong></p><pre><code>早些年的时候, 这种订阅被微软封掉的时候, 是只封管理员. 不封普通用户.最近出的订阅, 都是大批量产生的。被微软封的时候, 所有用户都被封不分管理和用户.订阅许可证 教师版 和 学生版 没有什么明显区别.一般被微软查到没有教育资格或者被举报, 都会有可能被封.有些许可证数量减少了, 从无限制(unlimited)减少到一个数量.这些订阅不正常的情况则是微软对该订阅有所限制了.</code></pre><p><strong>注意</strong>: 一般所出售的或者公开注册的,都不是老订阅.不要心存侥幸!</p><h3 id="Office365-A1P"><a href="#Office365-A1P" class="headerlink" title="Office365 A1P"></a><strong>Office365 A1P</strong></h3><p><strong>主要特征:</strong></p><pre><code>有Office365桌面版.无Azure Directory API操作权限.有管理员存在,才能在第三方应用挂载.有OneDrive for Busniess空间(1T~5T).正常情况下,许可证数量无限制(unlimited).</code></pre><p><strong>一些说明:</strong></p><blockquote><p>同 Microsoft Office365 A1 说明.</p></blockquote><h3 id="Office365-E3-MSDN"><a href="#Office365-E3-MSDN" class="headerlink" title="Office365 E3 MSDN"></a><strong>Office365 E3 MSDN</strong></h3><p><strong>主要特征:</strong></p><pre><code>有Office365桌面版.有Azure Directory API操作权限.有OneDrive for Busniess空间(1T~5T).正常情况下,许可证数量25个.</code></pre><p><strong>一些说明:</strong><br>    通过特殊链接注册,是微软提供给订阅MSDN的开发者权益之一.<br>    目前总体上来说,是使用来说最安心的订阅.<br>    现在微软改变条款了,MSDN订阅权益里面不再提供这种E3注册链接.<br>    目前市场上能看到卖的都是之前留下来的存货用一个少一个.<br>    每年(或每月)可自动免费续期,无需额外操作!<br>    官方的描述:”This subscription will automatically renewed all the time.”</p><h3 id="Office365-E3-Trial"><a href="#Office365-E3-Trial" class="headerlink" title="Office365 E3 Trial"></a><strong>Office365 E3 Trial</strong></h3><p><strong>主要特征:</strong></p><pre><code>无Office365桌面版.无Azure Directory API操作权限.有OneDrive for Busniess空间(1T~5T).正常情况下,许可证数量5个.</code></pre><p><strong>一些说明:</strong></p><pre><code>一年试用期,到期后如果想继续使用.那就要花钱去微软官方购买了!</code></pre><h3 id="Office365-Enterprise-E3-for-Symphony"><a href="#Office365-Enterprise-E3-for-Symphony" class="headerlink" title="Office365 Enterprise E3 for Symphony"></a><strong>Office365 Enterprise E3 for Symphony</strong></h3><p><strong>主要特征:</strong></p><pre><code>许可证数量最高可达到350万个.</code></pre><p><strong>一些说明:</strong></p><pre><code>订阅不稳,随时做好翻车准备.一般用于某宝奸商忽悠小白.其他订阅不细说了,自己琢磨一下!</code></pre><h2 id="风险说明"><a href="#风险说明" class="headerlink" title="风险说明"></a>风险说明</h2><p>无论是哪个版本？都没有100%的安全！存储任何重要的数据都要做好备份！</p><p><strong>Office365 E3 Trial 安全性最高，毕竟是准付费用户，正经方式上车。可惜不支持OFFICE桌面版，一年到期就得花钱了。</strong></p><p><strong>Office365 E3 MSDN 安全性不错，订阅特征支持的内容基本能满足我们的使用。并且有全局管理。特别推荐！不过目前E3的注册链接的价格水涨船高。17年10元一个链接已经不存在了！</strong></p><p>Office365 <strong>A1&#x2F;A1P 安全性比较低，之前博主更新过许多A1的注册地址。大部分都翻车了！</strong></p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Q：<strong>全局管理员能否查看用户OneDrive 存储的内容？</strong></p><p>A：是可以的！下图是管理员访问用户的OneDrive 设置，可见入口。</p><p><img src="https://b3logfile.com/file/2020/05/solofetchupload4974549952094187444-0bcd7697.jpeg"></p><p><strong>Q：Office365 E3 MSDN 三年到期后是否可以使用？</strong></p><p>A：是可以使用的！</p><p>在博主17年的文章中曾经说过理论上是到期后可以继续使用，当时只是看到微软官方的一个说明。现在第一波E3全局管理已经到期了，还是可以继续使用的！</p><p><strong>注：</strong><br>本文内容转载自：<a href="https://51.ruyo.net/11790.html">Office 365 A1&#x2F;A1P&#x2F;E3 MSDN&#x2F;E3 Trial 区别和常见问题</a></p>]]></content>
      
      
      <categories>
          
          <category> Office </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> Office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享—随机二次元图片API</title>
      <link href="//articles/2020/05/26/1590475418750.html"/>
      <url>//articles/2020/05/26/1590475418750.html</url>
      
        <content type="html"><![CDATA[<h2 id="二次元-API"><a href="#二次元-API" class="headerlink" title="二次元 API"></a>二次元 API</h2><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://moebi.org/pic.php">https://moebi.org/pic.php</a></p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>JSON</p><p><img src="https://b3logfile.com/file/2020/05/image-8cb307fb.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> API </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> API </tag>
            
            <tag> 二次元 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录.gitignore文件不起作用</title>
      <link href="//articles/2020/05/24/1590312447443.html"/>
      <url>//articles/2020/05/24/1590312447443.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开发过程中，我们自己会在.gitignore 文件中添加一些忽略项，然而，每次提交代码还是回有提示，原因是什么呐？</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore文件中已经声明了忽略路径也是不起作用的</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>应该先把本地缓存删除，然后再进行git的push，这样就不会出现忽略的文件了。</p><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#x27;update .gitignore&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EasyPOI—导出Excel图片问题</title>
      <link href="//articles/2020/04/27/1587970259806.html"/>
      <url>//articles/2020/04/27/1587970259806.html</url>
      
        <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>今天导出Excel使用EasyPoi工具，发现图片导出一直报错出现越界问题java.lang.ArrayIndexOutOfBoundsException: 0</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>报错java.lang.ArrayIndexOutOfBoundsException: 0或ExcelExportException: Excel导出错误</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cn.afterturn.easypoi.exception.excel.ExcelExportException: Excel导出错误</span><br><span class="line">at cn.afterturn.easypoi.excel.export.base.BaseExportService.createCells(BaseExportService.java:147) ~[easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.export.ExcelExportService.insertDataToSheet(ExcelExportService.java:178) [easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.export.ExcelExportService.createSheetForMap(ExcelExportService.java:145) [easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.export.ExcelExportService.createSheet(ExcelExportService.java:115) [easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.ExcelExportUtil.exportExcel(ExcelExportUtil.java:87) [easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at com.haier.hzy.admin.util.excel.ExcelUtils.defaultExport(ExcelUtils.java:49) [classes!/:1.0.0]</span><br><span class="line">at com.haier.hzy.admin.util.excel.ExcelUtils.exportExcel(ExcelUtils.java:40) [classes!/:1.0.0]</span><br><span class="line">at com.haier.hzy.weixin.controller.ActiveBackController.exportTopic(ActiveBackController.java:227) [classes!/:1.0.0]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_232]</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_232]</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_232]</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_232]</span><br><span class="line">at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:189) [spring-web-5.1.3.RELEASE.jar!/:5.1.3.RELEASE]</span><br><span class="line"></span><br><span class="line">java.lang.ArrayIndexOutOfBoundsException: 0</span><br><span class="line">at cn.afterturn.easypoi.util.PoiPublicUtil.getFileExtendName(PoiPublicUtil.java:147) ~[easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.export.base.BaseExportService.getImageType(BaseExportService.java:336) ~[easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.export.base.BaseExportService.createImageCell(BaseExportService.java:190) ~[easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.export.base.BaseExportService.createImageCell(BaseExportService.java:164) ~[easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.export.base.BaseExportService.createCells(BaseExportService.java:123) ~[easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.export.ExcelExportService.insertDataToSheet(ExcelExportService.java:178) ~[easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.export.ExcelExportService.createSheetForMap(ExcelExportService.java:145) ~[easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.export.ExcelExportService.createSheet(ExcelExportService.java:115) ~[easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at cn.afterturn.easypoi.excel.ExcelExportUtil.exportExcel(ExcelExportUtil.java:87) ~[easypoi-base-3.2.0.jar!/:na]</span><br><span class="line">at com.haier.hzy.admin.util.excel.ExcelUtils.defaultExport(ExcelUtils.java:49) ~[classes!/:1.0.0]</span><br><span class="line">at com.haier.hzy.admin.util.excel.ExcelUtils.exportExcel(ExcelUtils.java:40) ~[classes!/:1.0.0]</span><br><span class="line">at com.haier.hzy.weixin.controller.ActiveBackController.exportTopic(ActiveBackController.java:227) ~[classes!/:1.0.0]</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><blockquote><p>最后网上发现一篇文章 <a href="https://blog.csdn.net/qq_34988540/article/details/83050187">https://blog.csdn.net/qq_34988540&#x2F;article&#x2F;details&#x2F;83050187</a> 解释的很详细，包括源码！</p></blockquote><p>主要原因：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">图片的URL为空导致</span><br></pre></td></tr></table></figure><blockquote><p>可以看到是在ImageIO.write()我们图片url的时候得到了一个空的字节数组。<br>那么问题出来了，这里为什么返回了一个空的字节数组。从write方法的三个参数中的第二个参数我们可以看到这里将图片路径进行了字符串截取，截取的是第一个点以后的字符串，显然这是在截取图片的后缀名。<br>因为我们使用的图片路径为<a href="http://192.168.25.133/group1/M00/00/01/wKgZhVvC78SAfpWaAAAsAp7EzlE763.jpg%E3%80%82">http://192.168.25.133/group1/M00/00/01/wKgZhVvC78SAfpWaAAAsAp7EzlE763.jpg。</a> 随意第一个点之后的字符串显然有问题，所以这里应该截取最后一个点后面的字符串。</p></blockquote><blockquote><p>Easypoi的ImageCache为我们提供了setLoadingCache()方法，使得我们可以设置自己想要的loadingCache，所以，我们只需要自己重写一个loadingCache并赋值给ImageCache。<br>我们可以在Spring容器启动后把这个自定义的loadingCache赋值给ImageCache。</p></blockquote><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package com.haier.hzy.admin.util.excel.listener;</span><br><span class="line"> </span><br><span class="line">import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line"> </span><br><span class="line">import org.apache.poi.util.IOUtils;</span><br><span class="line">import org.springframework.boot.context.event.ApplicationReadyEvent;</span><br><span class="line">import org.springframework.context.ApplicationListener;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line">import com.google.common.cache.CacheBuilder;</span><br><span class="line">import com.google.common.cache.CacheLoader;</span><br><span class="line">import com.google.common.cache.LoadingCache;</span><br><span class="line"> </span><br><span class="line">import cn.afterturn.easypoi.cache.ImageCache;</span><br><span class="line">import cn.afterturn.easypoi.cache.manager.POICacheManager;</span><br><span class="line"> </span><br><span class="line">@Component</span><br><span class="line">public class ExcelListener implements ApplicationListener&lt;ApplicationReadyEvent&gt;&#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public void onApplicationEvent(ApplicationReadyEvent event) &#123;</span><br><span class="line"> LoadingCache&lt;String, byte[]&gt; loadingCache = CacheBuilder.newBuilder().expireAfterWrite(1, TimeUnit.DAYS)</span><br><span class="line">            .maximumSize(2000).build(new CacheLoader&lt;String, byte[]&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public byte[] load(String imagePath) throws Exception &#123;</span><br><span class="line">                    InputStream is = POICacheManager.getFile(imagePath);</span><br><span class="line">                    BufferedImage bufferImg = ImageIO.read(is);</span><br><span class="line">                    ByteArrayOutputStream byteArrayOut = new ByteArrayOutputStream();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        ImageIO.write(bufferImg,</span><br><span class="line">                            imagePath.substring(imagePath.lastIndexOf(&quot;.&quot;)+1),</span><br><span class="line">                            byteArrayOut);</span><br><span class="line">                        return byteArrayOut.toByteArray();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        IOUtils.closeQuietly(is);</span><br><span class="line">                        IOUtils.closeQuietly(byteArrayOut);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">ImageCache.setLoadingCache(loadingCache);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>这个问题好像很久了，目前easypoi版本都是4.0了，好像还是没有修复！归根结底就是URL截取问题！</p><p>最后好像webp图片还不能解析，网上资料需要单独解析，没做深究，自行研究！</p>]]></content>
      
      
      <categories>
          
          <category> EasyPOI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> Java </tag>
            
            <tag> EasyPOI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github+jsDelivr为脚本/图片等静态文件加速的全球CDN</title>
      <link href="//articles/2020/04/01/1585736011733.html"/>
      <url>//articles/2020/04/01/1585736011733.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>众所周知，Github是目前最大的项目的托管平台，而且免费套餐还支持私有仓库了！但是呐，国内访问比较慢！！</p></blockquote><p>今天给介绍一种加速访问方式 <code>jsDelivr CDN</code></p><p>jsDelivr提供npm，GitHub，WordPress等项目的镜像，全球加速访问！</p><p>针对Github提供免费的CDN加速，在国内使用的是网宿的CDN加速！访问速度一点儿都不慢！</p><h2 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h2><ul><li>目前Github仓库容量是没有上限的！不过官方推荐在1G以内！</li><li>仓库单个文件50M会收到警告，大于100M会被拒绝！</li><li>jsDelivr仅能针对50M以下的文件CDN加速！</li></ul><p>但是利用它读取静态文件处处有余，如JS、CSS、图片、文件等！</p><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><blockquote><p>这里以图床方式</p></blockquote><ul><li>创建一个 GitHub 仓库作为图床仓库，上传提交图片到仓库中</li><li>在要使用 GitHub 图床图片的地方将链接换为 <a href="https://cdn.jsdelivr.net/gh/%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BD%A0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D@%E5%8F%91%E5%B8%83%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84">https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径</a></li></ul><p><strong>例如</strong>：<a href="https://cdn.jsdelivr.net/gh/JssDream/image-hosting/img/002_2.jpg">https://cdn.jsdelivr.net/gh/JssDream/image-hosting/img/002_2.jpg</a></p><p>简单吧！！！:huaji:</p><blockquote><p>转自：<a href="https://51.ruyo.net/15149.html">如有乐享</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> GitHub </tag>
            
            <tag> jsDelivr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【薅羊毛】招商 APP- 理财福利</title>
      <link href="//articles/2020/03/27/1585289293648.html"/>
      <url>//articles/2020/03/27/1585289293648.html</url>
      
        <content type="html"><![CDATA[<h1 id="理财福利"><a href="#理财福利" class="headerlink" title="理财福利"></a>理财福利</h1><p><strong>活动网址</strong>：<br><a href="https://act.cmbchina.com/ActShipMobile/Pages/PointDrawDetail.aspx?ActGroupID=AGP20200324163540kGXdzzbH&behavior_entryid=yyg003002&version=8.1.5">https://act.cmbchina.com/ActShipMobile/Pages/PointDrawDetail.aspx?ActGroupID=AGP20200324163540kGXdzzbH&behavior_entryid&#x3D;yyg003002&amp;version&#x3D;8.1.5</a></p><p>或者打开招商APP找到学理财赢红包</p><p><img src="https://img.hacpai.com/file/2020/03/%E5%9B%BE%E7%89%87-34d54f93.png" alt="图片.png"></p><p>需要支付1分钱买货币基金，随时可提取</p><p><strong>红包抽奖最低6.6元，最高88元</strong></p><h2 id="重点有反馈说-2020-年买过的好像就不能参与了"><a href="#重点有反馈说-2020-年买过的好像就不能参与了" class="headerlink" title="重点有反馈说 2020 年买过的好像就不能参与了"></a>重点有反馈说 2020 年买过的好像就不能参与了</h2><h2 id="二维码直通车"><a href="#二维码直通车" class="headerlink" title="二维码直通车"></a>二维码直通车</h2><p><img src="https://img.hacpai.com/file/2020/03/%E5%9B%BE%E7%89%87-df514aea.png" alt="图片.png"></p><h5 id="最低6-6元！最低6-6元！最低6-6元！真香！-huaji"><a href="#最低6-6元！最低6-6元！最低6-6元！真香！-huaji" class="headerlink" title="最低6.6元！最低6.6元！最低6.6元！真香！:huaji:"></a>最低6.6元！最低6.6元！最低6.6元！真香！:huaji:</h5>]]></content>
      
      
      <categories>
          
          <category> 福利 </category>
          
          <category> 薅羊毛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 福利 </tag>
            
            <tag> 薅羊毛 </tag>
            
            <tag> 推广 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jenkins—500错误分析(磁盘空间不足)</title>
      <link href="//articles/2019/12/13/1576226764937.html"/>
      <url>//articles/2019/12/13/1576226764937.html</url>
      
        <content type="html"><![CDATA[<h2 id="一次Jenkins–500错误的分析"><a href="#一次Jenkins–500错误的分析" class="headerlink" title="一次Jenkins–500错误的分析"></a>一次Jenkins–500错误的分析</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><pre><code>打开gitlab发现报错500，一开始以为是网络问题，但是试了好几次发现不是，进入后台开始排查问题</code></pre><p><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-ef55fcff.png" alt="图片.png"></p><h3 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h3><ul><li>检查gitLab状态(重启)</li></ul><blockquote><p>gitlab-ctl restart 重启没有问题</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# gitlab-ctl status</span><br><span class="line">run: alertmanager: (pid 3364) 5006471s; run: log: (pid 3348) 5006471s</span><br><span class="line">run: gitaly: (pid 3355) 5006471s; run: log: (pid 3352) 5006471s</span><br><span class="line">run: gitlab-monitor: (pid 82813) 6875s; run: log: (pid 3353) 5006471s</span><br><span class="line">run: gitlab-workhorse: (pid 3360) 5006471s; run: log: (pid 3357) 5006471s</span><br><span class="line">run: grafana: (pid 3373) 5006471s; run: log: (pid 3372) 5006471s</span><br><span class="line">run: logrotate: (pid 110986) 2429s; run: log: (pid 3351) 5006471s</span><br><span class="line">run: nginx: (pid 3359) 5006471s; run: log: (pid 3356) 5006471s</span><br><span class="line">run: node-exporter: (pid 3362) 5006471s; run: log: (pid 3349) 5006471s</span><br><span class="line">run: postgres-exporter: (pid 3363) 5006471s; run: log: (pid 3350) 5006471s</span><br><span class="line">run: postgresql: (pid 3344) 5006471s; run: log: (pid 3341) 5006471s</span><br><span class="line">run: prometheus: (pid 3378) 5006471s; run: log: (pid 3375) 5006471s</span><br><span class="line">run: redis: (pid 3368) 5006471s; run: log: (pid 3366) 5006471s</span><br><span class="line">run: redis-exporter: (pid 3347) 5006471s; run: log: (pid 3346) 5006471s</span><br><span class="line">run: sidekiq: (pid 3370) 5006471s; run: log: (pid 3367) 5006471s</span><br><span class="line">run: unicorn: (pid 3343) 5006471s; run: log: (pid 3342) 5006471s</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>gitlab-ctl status 当前状态没有问题</p></blockquote><ul><li>检查端口</li></ul><blockquote><p>netstat -tnlp | grep 8898 没有问题</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# netstat -tnlp | grep 8898</span><br><span class="line">tcp        0      0 0.0.0.0:8898            0.0.0.0:*               LISTEN      3359/nginx: master </span><br></pre></td></tr></table></figure><ul><li>查看日志</li></ul><blockquote><p>gitlab-ctl tail 发现问题</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">==&gt; /var/log/gitlab/prometheus/current &lt;==</span><br><span class="line">2019-12-13_05:47:20.83161 level=warn ts=2019-12-13T04:12:25.157365383Z caller=scrape.go:867 component=&quot;scrape manager&quot; scrape_pool=gitlab-workhorse target=http://localhost:9229/metrics msg=&quot;append failed&quot; err=&quot;write to WAL: log samples: create new segment file: open /var/opt/gitlab/prometheus/data/wal/00000997: no space left on device&quot;</span><br><span class="line">2019-12-13_05:47:20.83162 level=warn ts=2019-12-13T04:12:50.082097379Z caller=manager.go:532 component=&quot;rule manager&quot; group=Node msg=&quot;rule sample appending failed&quot; err=&quot;write to WAL: log samples: create new segment file: open /var/opt/gitlab/prometheus/data/wal/00000997: no space left on device&quot;</span><br><span class="line">....</span><br><span class="line">==&gt; /var/log/gitlab/alertmanager/state &lt;==</span><br></pre></td></tr></table></figure><blockquote><p>问题出现<code>no space left on device</code>，没有空间了！！！！</p></blockquote><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><ul><li><p>查看当前磁盘空间</p></li><li><p>通过命令df -h，发现系统各个文件夹的空寂，我们清理磁盘即可</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1        50G   12G   35G  26% /</span><br><span class="line">devtmpfs        911M     0  911M   0% /dev</span><br><span class="line">tmpfs           920M   24K  920M   1% /dev/shm</span><br><span class="line">tmpfs           920M  476K  920M   1% /run</span><br><span class="line">tmpfs           920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           184M     0  184M   0% /run/user/0</span><br><span class="line">overlay          50G   12G   35G  26% /var/lib/docker/overlay2/509b42fa7d1ebe1054a897459cfeea3423324f203258aabf26e5471e33b62ceb/merged</span><br><span class="line">shm              64M     0   64M   0% /var/lib/docker/containers/5691ecf7f4fab7a142e6ca4043e59830fda0073397fc80534e790c69de62b380/mounts/shm</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><blockquote><p>使用 du -sh查看linux硬盘各个文件占用空间统计</p></blockquote><ul><li><code>du -sh /var/lib/*|grep &quot;G&quot;</code></li></ul><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><ul><li>显示每个文件和目录的磁盘使用空间（文件的大小）<blockquote><p>disk usage,是通过搜索文件来计算每个文件的大小然后累加，du能看到的文件只是一些当前存在的，没有被删除的。他计算的大小就是当前他认为存在的所有文件大小的累加和。</p></blockquote></li></ul><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><ul><li>显示磁盘分区上可以使用的磁盘空间</li></ul><blockquote><p>disk free，通过文件系统来快速获取空间大小的信息，当我们删除一个文件的时候，这个文件不是马上就在文件系统当中消失了，而是暂时消失了，当所有程序都不用时，才会根据OS的规则释放掉已经删除的文件，df记录的是通过文件系统获取到的文件的大小，他比du强的地方就是能够看到已经删除的文件，而且计算大小的时候，把这一部分的空间也加上了，更精确了。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Jenkins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔鬼命令 </tag>
            
            <tag> 随记 </tag>
            
            <tag> Jenkins </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分享工具箱(图床、短链、趣图、榜单、在线音乐)</title>
      <link href="//articles/2019/12/12/1576119045214.html"/>
      <url>//articles/2019/12/12/1576119045214.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现一位大佬做了一个工具箱，功能基本包含了榜单、图床、短链、趣图、在线音乐，感觉很有趣，分享下！</p><h3 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h3><p><a href="https://www.cloudbed.vip/index.html">瓜娃工具箱</a></p><h2 id="榜单"><a href="#榜单" class="headerlink" title="榜单"></a>榜单</h2><blockquote><p>进入网站首先是几个网站实时榜单(后面应该会持续更新)</p></blockquote><ul><li>博客园</li><li>IT之家</li><li>虎扑</li><li>开源中国</li><li>雷锋网</li><li>前瞻网</li></ul><p><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-7306e73a.png" alt="图片.png"></p><h2 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h2><blockquote><p>图床功能包括了图片上传、预览，还是不错的(PS:图床设置了鉴黄功能，使用人工智能，通过训练机器人达到鉴黄，可以多多益善哦 :huaji: )</p></blockquote><p><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-92dc4b87.png" alt="图片.png"><br><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-3193cde9.png" alt="图片.png"><br><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-75916013.png" alt="图片.png"></p><h2 id="短链"><a href="#短链" class="headerlink" title="短链"></a>短链</h2><blockquote><p>这个短链功能还是很实用的，作用大家都知道就不多说了，有还原和生成短链功能</p></blockquote><p><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-95f3a1b4.png" alt="图片.png"></p><h2 id="摸鱼"><a href="#摸鱼" class="headerlink" title="摸鱼"></a>摸鱼</h2><h3 id="趣味动图"><a href="#趣味动图" class="headerlink" title="趣味动图"></a>趣味动图</h3><p>:doge:<br><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-043a6168.png" alt="图片.png"></p><h3 id="在线音乐"><a href="#在线音乐" class="headerlink" title="在线音乐"></a>在线音乐</h3><blockquote><p> 在线音乐支持搜索！(默认网易音乐)</p></blockquote><p><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-4b070cd0.png" alt="图片.png"><br><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-dc9f9cb1.png" alt="图片.png"></p><h3 id="闲聊么"><a href="#闲聊么" class="headerlink" title="闲聊么"></a>闲聊么</h3><blockquote><p>闲聊么功能，需要微信扫码，进去在线聊天，当然目前没什么活跃量🤣<br>网站右下角点击进入 </p></blockquote><p><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-5094e45b.png" alt="图片.png"><br><img src="https://img.hacpai.com/file/2019/12/%E5%9B%BE%E7%89%87-c3effa46.png" alt="图片.png"></p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>:huaji: 再也不用担心没地方摸鱼了！</p>]]></content>
      
      
      <categories>
          
          <category> 工具箱 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔记—获取请求IP方法整理</title>
      <link href="//articles/2019/12/04/1575442618755.html"/>
      <url>//articles/2019/12/04/1575442618755.html</url>
      
        <content type="html"><![CDATA[<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 获取真实IP</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * X-Forwarded-For：Squid 服务代理 只有在通过了HTTP代理或者负载均衡服务器时才会添加该项，</span><br><span class="line">     * 格式为X-Forwarded-For:client1,proxy1,proxy2，一般情况下，第一个ip为客户端真实ip，后面的为经过的代理服务器ip</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * Proxy-Client-IP：apache 服务代理</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * WL-Proxy-Client-IP：weblogic 服务代理</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * HTTP_CLIENT_IP：有些代理服务器</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * X-Real-IP：nginx服务代理</span><br><span class="line">     *</span><br><span class="line">     * @param request 请求体</span><br><span class="line">     * @return 真实IP</span><br><span class="line">     */</span><br><span class="line">    public static String getRealIp(HttpServletRequest request) &#123;</span><br><span class="line">        // 这个一般是Nginx反向代理设置的参数</span><br><span class="line">        String ip = request.getHeader(&quot;X-Real-IP&quot;);</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;X-Forwarded-For&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;</span><br><span class="line">            ip = request.getRemoteAddr();</span><br><span class="line">        &#125;</span><br><span class="line">        //根据网卡取本机配置的IP</span><br><span class="line">//        if(ip.equals(&quot;127.0.0.1&quot;) || ip.equals(&quot;0:0:0:0:0:0:0:1&quot;))&#123;</span><br><span class="line">//            InetAddress inet=null;</span><br><span class="line">//            try &#123;</span><br><span class="line">//                inet = InetAddress.getLocalHost();</span><br><span class="line">//            &#125; catch (UnknownHostException e) &#123;</span><br><span class="line">//                e.printStackTrace();</span><br><span class="line">//            &#125;</span><br><span class="line">//            ip= inet.getHostAddress();</span><br><span class="line">//        &#125;</span><br><span class="line">        // 处理多IP的情况（只取第一个IP）</span><br><span class="line">        if (ip != null &amp;&amp; ip.contains(&quot;,&quot;)) &#123;</span><br><span class="line">            String[] ipArray = ip.split(&quot;,&quot;);</span><br><span class="line">            ip = ipArray[0];</span><br><span class="line">        &#125;</span><br><span class="line">        ip = ip.equals(&quot;0:0:0:0:0:0:0:1&quot;) ? &quot;127.0.0.1&quot; : ip;</span><br><span class="line">        return ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><blockquote><p>获取用户真实IP地址，为什么不直接使用request.getRemoteAddr()的原因是有可能用户使用了代理方式避免真实IP地址，如果使用了代理就可能出现多级反向代理，那X-Forwarded-For的值并不止一个，而是一串IP值，至于哪个才是真正的用户端的真实IP? 答案是取X-Forwarded-For中第一个非unknown的有效IP字符串，而且可能获取的是代理服务器的IP</p></blockquote><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电影分享—小丑.Joker.2019.HD1080P. 韩版英语中字</title>
      <link href="//articles/2019/11/15/1573787853367.html"/>
      <url>//articles/2019/11/15/1573787853367.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://img.hacpai.com/file/2019/11/4c91c75c1038534380daed589c13b07ecb8088e9-47770c22.jpg" alt="4c91c75c1038534380daed589c13b07ecb8088e9.jpg"><br><img src="https://img.hacpai.com/file/2019/11/image-0650f2ad.png" alt="image.png"></p><p>最近网上好像又开始疯传小丑了，这部电影一直想看，但一直没有看！这次周末必须看下，看看这部真实反映社会现状的神作是什么样的！！</p><p><img src="https://img.hacpai.com/file/2019/11/388f960a304e251f66f6ed81a886c9177e3e5385-9ee76864.png" alt="388f960a304e251f66f6ed81a886c9177e3e5385.png"></p><p><img src="https://img.hacpai.com/file/2019/11/78523801213fb80ec1d768ae39d12f2eb8389484-368716b4.png" alt="78523801213fb80ec1d768ae39d12f2eb8389484.png"><br>强烈推荐！！</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><h3 id="普通-有效期-7-天"><a href="#普通-有效期-7-天" class="headerlink" title="普通(有效期 7 天)"></a>普通(有效期 7 天)</h3><p><strong>自行百度</strong> :huaji:</p>]]></content>
      
      
      <categories>
          
          <category> 影视资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影视资源 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot自定义参数解析器—HandlerMethodArgumentResolver</title>
      <link href="//articles/2019/11/08/1573203264692.html"/>
      <url>//articles/2019/11/08/1573203264692.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>使用自定义参数解析器进行全局参数(用户信息UserInfo)注入，可以使用注解，也可以直接对象！</p><p><code>HandlerMethodArgumentResolver</code>：处理函数参数的分解器，自定义需要实现这个接口(在SpringMVC中也可以使用)</p><p><img src="https://img.hacpai.com/file/2019/11/image-3bd68181.png" alt="image.png"></p><blockquote><p>接口方法</p></blockquote><ul><li><code>supportsParameter</code>：用于判定是否需要处理该参数分解，必须返回true才会去调用下面的方法resolveArgument。(博主之前就是这个问题)  </li><li><code>resolveArgument</code>：真正用于处理参数分解的方法，返回的Object就是controller方法上的形参对象</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>博主使用的是<code>UserInfo</code>对象注入(注解方式自行百度)</p><h3 id="自定义参数解析器，实现HandlerMethodArgumentResolver接口"><a href="#自定义参数解析器，实现HandlerMethodArgumentResolver接口" class="headerlink" title="自定义参数解析器，实现HandlerMethodArgumentResolver接口"></a>自定义参数解析器，实现HandlerMethodArgumentResolver接口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package com.bigbigsun.assets.admin.config;</span><br><span class="line"></span><br><span class="line">import cn.hutool.core.util.StrUtil;</span><br><span class="line">import com.alibaba.fastjson.JSON;</span><br><span class="line">import com.alibaba.fastjson.JSONObject;</span><br><span class="line">import com.jssdream.common.redis.RedisTemplateUtil;</span><br><span class="line">import com.jssdream.common.util.TokenUtil;</span><br><span class="line">import com.jssdream.common.util.User;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.core.MethodParameter;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.web.bind.support.WebDataBinderFactory;</span><br><span class="line">import org.springframework.web.context.request.NativeWebRequest;</span><br><span class="line">import org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line">import org.springframework.web.method.support.ModelAndViewContainer;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * 将登陆用户可以直接注入的形式获取</span><br><span class="line"> */</span><br><span class="line">@Service</span><br><span class="line">public class UserArgumentResolver implements HandlerMethodArgumentResolver &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    RedisTemplateUtil redisService;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean supportsParameter(MethodParameter methodParameter) &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = methodParameter.getParameterType();</span><br><span class="line">        return clazz== User.class;</span><br><span class="line">//也可以</span><br><span class="line">/*return true;</span><br><span class="line">return parameter.hasParameterAnnotation(User.class);*/</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object resolveArgument(MethodParameter methodParameter, ModelAndViewContainer modelAndViewContainer,</span><br><span class="line">                                  NativeWebRequest nativeWebRequest, WebDataBinderFactory webDataBinderFactory) &#123;</span><br><span class="line">        HttpServletRequest request = nativeWebRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">        //获取token</span><br><span class="line">        String token = TokenUtil.getToken(request);</span><br><span class="line">        User userInfo = StrUtil.isBlank(token) ? null : JSONObject.toJavaObject(JSON.parseObject(redisService.getKey(token)),User.class);</span><br><span class="line">        if(userInfo == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return userInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="将UserArgumentResolver加入到WebMvcConfigurerAdapter中"><a href="#将UserArgumentResolver加入到WebMvcConfigurerAdapter中" class="headerlink" title="将UserArgumentResolver加入到WebMvcConfigurerAdapter中"></a>将UserArgumentResolver加入到WebMvcConfigurerAdapter中</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.jssdream.admin.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.method.support.HandlerMethodArgumentResolver;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class WebConfig extends WebMvcConfigurerAdapter &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserArgumentResolver userArgumentResolver;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers) &#123;</span><br><span class="line">        argumentResolvers.add(userArgumentResolver);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Controller中使用用户信息"><a href="#Controller中使用用户信息" class="headerlink" title="Controller中使用用户信息"></a>Controller中使用用户信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;user&quot;)</span><br><span class="line">public User getUser(User user)&#123;</span><br><span class="line">   </span><br><span class="line">    return user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>WebMvcConfigurerAdapter这个抽象类中的方法可以看一看，addInterceptors可以添加拦截器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addInterceptors(InterceptorRegistry registry) &#123;</span><br><span class="line">         // 拦截所有请求，进行判断</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot——@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</title>
      <link href="//articles/2019/10/30/1572431859394.html"/>
      <url>//articles/2019/10/30/1572431859394.html</url>
      
        <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>在Spring Boot中启动类是默认加载数据库配置的</p><ul><li><p>如果在启动类的配置上加了注解<code>@SpringBootApplication(exclude= DataSourceAutoConfiguration.class)</code>，项目也没有自己配置自定义DataSource那么在项目启动的时候会报数据源找不到</p></li><li><p>还有一种可能是在application.properties压根没有配置数据库配置，也会报数据源找不到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">***************************  </span><br><span class="line">APPLICATION FAILED TO START  </span><br><span class="line">***************************  </span><br><span class="line">  </span><br><span class="line">Description:  </span><br><span class="line">  </span><br><span class="line">Failed to configure a DataSource: &#x27;url&#x27; attribute is not specified and no embedded datasource could be configured.  </span><br><span class="line">  </span><br><span class="line">Reason: Failed to determine a suitable driver class  </span><br></pre></td></tr></table></figure></li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><blockquote><p>在Spring Boot 中配置Dubbo的时候，在消费者模块不需要配置数据库信息，这个时候在启动类上面添加注解<br><code>@SpringBootApplication(exclude= DataSourceAutoConfiguration.class)</code>没有问题！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>薅羊毛——0元撸腾讯云服务器(云硬盘...)</title>
      <link href="//articles/2019/10/29/1572314884193.html"/>
      <url>//articles/2019/10/29/1572314884193.html</url>
      
        <content type="html"><![CDATA[<h2 id="撸"><a href="#撸" class="headerlink" title="撸"></a>撸</h2><p><img src="https://img.hacpai.com/file/2019/10/image-31fac8f5.png" alt="image.png"></p><blockquote><p>领取腾讯云代金券</p></blockquote><ul><li><a href="https://cloud.tencent.com/act/pro/Techodeveloper">100元无门槛代金券</a></li></ul><p>为了更好的购买体验，建议前往PC端使用代金券</p><h3 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h3><p><img src="https://img.hacpai.com/file/2019/10/image-99d322fd.png" alt="image.png"></p><p>适用产品：点播-存储包、点播-转码包、点播-流量包、实时音视频-预付费套餐包、实时视频通话-时长套餐包、云服务器、云数据库（MySQL）、云数据库HBase、云数据库Redis、云数据库（SQL Server）、云数据库（MariaDB）、云硬盘、MongoDB、负载均衡、云数据库（PostgreSQL）、CDN流量包、cos资源包(标准存储100G)、cos资源包(标准存储200G)、cos资源包(标准存储500G)、cos资源包(标准存储2048G)、cos资源包(标准存储10240G)、cos资源包(标准存储51200G)、cos资源包(归档存储100G)、cos资源包(归档存储200G)、cos资源包(归档存储500G)、cos资源包(归档存储2048G)、cos资源包(归档存储10240G)、cos资源包(归档存储51200G)、cos资源包(IDC流量100G)、cos资源包(IDC流量200G)、cos资源包(IDC流量500G)</p><h4 id="使用条件：新购-限购时长1-12个月"><a href="#使用条件：新购-限购时长1-12个月" class="headerlink" title="使用条件：新购, 限购时长1-12个月"></a>使用条件：<strong>新购, 限购时长1-12个月</strong></h4><h3 id="服务器地址"><a href="#服务器地址" class="headerlink" title="服务器地址"></a>服务器地址</h3><blockquote><p>地址 <a href="https://buy.cloud.tencent.com/cvm?tab=lite">云服务器</a></p></blockquote><p><img src="https://img.hacpai.com/file/2019/10/image-0db2a8f4.png" alt="image.png"></p><h3 id="硬盘地址"><a href="#硬盘地址" class="headerlink" title="硬盘地址"></a>硬盘地址</h3><blockquote><p>地址 <a href="https://cloud.tencent.com/product/cbs">云硬盘</a></p></blockquote><p><img src="https://img.hacpai.com/file/2019/10/image-aec26a1f.png" alt="image.png"></p><p>from：<a href="https://www.52pojie.cn/thread-1045145-1-1.html">https://www.52pojie.cn/thread-1045145-1-1.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 福利 </category>
          
          <category> 薅羊毛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 福利 </tag>
            
            <tag> 薅羊毛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年京东双十一活动——全民养红包</title>
      <link href="//articles/2019/10/22/1571713204417.html"/>
      <url>//articles/2019/10/22/1571713204417.html</url>
      
        <content type="html"><![CDATA[<h2 id="啦啦啦"><a href="#啦啦啦" class="headerlink" title="啦啦啦"></a>啦啦啦</h2><p>今年京东双十一的全民养红包活动，网上惊现刷金币脚本！现分享出来：</p><ol><li>首次参加，先打开京东APP，首页右侧浮标“疯抢一亿”开启活动<br><img src="https://img.hacpai.com/file/2019/10/image-4e8f3fe6.png" alt="image.png"></li><li>浏览器打开：<a href="https://happy.m.jd.com/babelDiy/GZWVJFLMXBQVEBDQZWMY/XJf8bH6oXDWSgS91daDJzXh9bU7/index.html#/failback">https://happy.m.jd.com/babelDiy/GZWVJFLMXBQVEBDQZWMY/XJf8bH6oXDWSgS91daDJzXh9bU7/index.html#/failback</a></li><li>F12&#x3D;&gt;console&#x3D;&gt;粘贴脚本，回车运行（几分钟左右）</li><li>确认自己已经<strong>登录了京东账号</strong>，电脑版运行脚本无视页面显示的内容<br><img src="https://img.hacpai.com/file/2019/10/image-8d794ffa.png" alt="image.png"></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">let productList = [], shopList = [], url = &quot;https://api.m.jd.com/client.action&quot;;</span><br><span class="line">function autoPost(id,type)&#123;</span><br><span class="line">        fetch(`$&#123;url&#125;?timestamp=$&#123;new Date().getTime()&#125;`,&#123;method: &quot;POST&quot;,mode: &quot;cors&quot;,credentials: &quot;include&quot;,headers:&#123;&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&#125;,body:`functionId=raisepacket_collectScore&amp;body=&#123;&quot;type&quot;:$&#123;type&#125;,&quot;ext&quot;:&quot;$&#123;id&#125;&quot;,&quot;appsign&quot;:1,&quot;msgsign&quot;:2&#125;&amp;client=wh5`&#125;)</span><br><span class="line">                .then(function(response)&#123;return response.json()&#125;)</span><br><span class="line">                .then(function(res)&#123;</span><br><span class="line">                        console.log(res.data.biz_msg);</span><br><span class="line">                &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function start()&#123;</span><br><span class="line">        fetch(`$&#123;url&#125;?$&#123;new Date().getTime()&#125;`,&#123;method: &quot;POST&quot;,mode: &quot;cors&quot;,credentials: &quot;include&quot;,headers:&#123;&quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&#125;,body:&#x27;functionId=raisepacket_getShopAndProductList&amp;body=&amp;client=wh5&#x27;&#125;)</span><br><span class="line">                .then(function(response)&#123;return response.json()&#125;)</span><br><span class="line">                .then(function(res)&#123;</span><br><span class="line">                        productList = res.data.result.productList;</span><br><span class="line">                        shopList  = res.data.result.shopList;</span><br><span class="line">                        console.log(`获取到任务,商品：$&#123;productList.length&#125; 商品：$&#123;shopList.length&#125;`);</span><br><span class="line">                        autoProductTask();</span><br><span class="line">                &#125;);</span><br><span class="line">&#125;</span><br><span class="line">//逛商品</span><br><span class="line">function autoProductTask()&#123;</span><br><span class="line">        for(let i = 0,leng = productList.length;i&lt;leng;i++)&#123;</span><br><span class="line">                (function(index)&#123;</span><br><span class="line">                        setTimeout(()=&gt;&#123;</span><br><span class="line">                                let item = productList[index];</span><br><span class="line">                                autoPost(item[&#x27;id&#x27;],4);</span><br><span class="line">                                console.log(`商品总任务数：$&#123;leng&#125; 当前任务数：$&#123;index + 1&#125;`);</span><br><span class="line">                                if( leng-1 == index)&#123;</span><br><span class="line">                                        autoShopTask();</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;,index*1500)</span><br><span class="line">                &#125;)(i)      </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">//逛店铺</span><br><span class="line">function autoShopTask()&#123;</span><br><span class="line">        for(let i = 0,leng = shopList.length;i&lt;leng;i++)&#123;</span><br><span class="line">                (function(index)&#123;</span><br><span class="line">                        setTimeout(()=&gt;&#123;</span><br><span class="line">                                let item = shopList[index];</span><br><span class="line">                                autoPost(item[&#x27;id&#x27;],2);</span><br><span class="line">                                console.log(`商铺总任务数：$&#123;leng&#125; 当前任务数：$&#123;index + 1&#125;`);</span><br><span class="line">                                if( leng-1 == index)&#123;</span><br><span class="line">                                        autoPlay();</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;,index*1500)</span><br><span class="line">                &#125;)(i)      </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">//好玩互动</span><br><span class="line">function autoPlay()&#123;</span><br><span class="line">        for(let i = 0,leng = 4;i&lt;leng;i++)&#123;</span><br><span class="line">                (function(index)&#123;</span><br><span class="line">                        setTimeout(()=&gt;&#123;</span><br><span class="line">                                autoPost(0,5);</span><br><span class="line">                                console.log(`好玩互动：$&#123;leng&#125; 当前任务数：$&#123;index + 1&#125;`);</span><br><span class="line">                                if( leng-1 == index)&#123;</span><br><span class="line">                                        autoInteract();</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;,index*1000)</span><br><span class="line">                &#125;)(i)      </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">//视频直播</span><br><span class="line">function autoInteract()&#123;</span><br><span class="line">        for(let i = 0,leng = 4;i&lt;leng;i++)&#123;</span><br><span class="line">                (function(index)&#123;</span><br><span class="line">                        setTimeout(()=&gt;&#123;</span><br><span class="line">                                autoPost(0,10);</span><br><span class="line">                                console.log(`视频直播：$&#123;leng&#125; 当前任务数：$&#123;index + 1&#125;`);</span><br><span class="line">                                if( leng-1 == index)&#123;</span><br><span class="line">                                        autoShopping();</span><br><span class="line">                                &#125;</span><br><span class="line">                        &#125;,index*1000)</span><br><span class="line">                &#125;)(i)      </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">//精彩会场</span><br><span class="line">function autoShopping()&#123;</span><br><span class="line">        for(let i = 0,leng = 3;i&lt;leng;i++)&#123;</span><br><span class="line">                (function(index)&#123;</span><br><span class="line">                        setTimeout(()=&gt;&#123;</span><br><span class="line">                                autoPost(0,3);</span><br><span class="line">                                console.log(`精彩会场：$&#123;leng&#125; 当前任务数：$&#123;index + 1&#125;`);</span><br><span class="line">                                &#125;,</span><br><span class="line">                        index*1000)</span><br><span class="line">                &#125;)(i)      </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">start();</span><br></pre></td></tr></table></figure><h3 id="有人问，提示完成以后干啥？提示完成是帮你自动获取了金币，你需要手动在京东app打开活动，点击投喂，把金币消耗掉，把红包等级提上去！"><a href="#有人问，提示完成以后干啥？提示完成是帮你自动获取了金币，你需要手动在京东app打开活动，点击投喂，把金币消耗掉，把红包等级提上去！" class="headerlink" title="有人问，提示完成以后干啥？提示完成是帮你自动获取了金币，你需要手动在京东app打开活动，点击投喂，把金币消耗掉，把红包等级提上去！"></a>有人问，提示完成以后干啥？提示完成是帮你自动获取了金币，你需要手动在京东app打开活动，点击投喂，把金币消耗掉，把红包等级提上去！</h3><h2 id="白白"><a href="#白白" class="headerlink" title="白白"></a>白白</h2><blockquote><p>每天都可以运行一次(前提没有被封！)</p></blockquote><blockquote><p>来源福利吧，非本人原创</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 京东 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 福利 </tag>
            
            <tag> 活动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>罗小黑战记——百度网盘4K资源</title>
      <link href="//articles/2019/10/19/1571469540711.html"/>
      <url>//articles/2019/10/19/1571469540711.html</url>
      
        <content type="html"><![CDATA[<h2 id="Begin"><a href="#Begin" class="headerlink" title="Begin"></a>Begin</h2><pre><code>周末了，终于可以休息了，躺在床上看一部电影(动漫、电视剧、综艺)，这是多么享受，Enjoy Time！</code></pre><p>话说2019年国内的动画真是逆天了有没有，要崛起的节奏</p><blockquote><p>先有《<strong>哪吒之魔童降世</strong>》“我命由我不由天”</p></blockquote><blockquote><p>后有《<strong>罗小黑战记</strong>》“人和妖一样，很难定义好坏，好坏在不同人眼里也不是绝对的。”</p></blockquote><h2 id="罗小黑战记"><a href="#罗小黑战记" class="headerlink" title="罗小黑战记"></a>罗小黑战记</h2><p><img src="https://img.hacpai.com/file/2019/10/image-4f0e0282.png" alt="image.png"></p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>链接: <a href="https://pan.baidu.com/s/1nqZ1C1gQZzTOcS7Il6tXeg&shfl=shareset">https://pan.baidu.com/s/1nqZ1C1gQZzTOcS7Il6tXeg&amp;shfl=shareset</a> 提取码: 8n4x </p><h3 id="热评"><a href="#热评" class="headerlink" title="热评"></a>热评</h3><p><img src="https://img.hacpai.com/file/2019/10/image-594d4005.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 影视资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影视资源 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《黑客军团》第一二三季——美剧分享</title>
      <link href="//articles/2019/10/17/1571301097079.html"/>
      <url>//articles/2019/10/17/1571301097079.html</url>
      
        <content type="html"><![CDATA[<h2 id="黑客军团"><a href="#黑客军团" class="headerlink" title="黑客军团"></a>黑客军团</h2><h3 id="剧情简介"><a href="#剧情简介" class="headerlink" title="剧情简介"></a>剧情简介</h3><p>本剧的主角为艾略特·奥尔德森 (Elliot Alderson)，他居住在纽约市，是一名网络安全工程师。晚上，他化身为一名黑客。艾略特患有社交恐惧症。艾略特遇见了一个神秘的无政府主义者，他名为机器人先生 (Mr. Robot) 。机器人先生招募艾略特加入他的黑客组织“反社会 (fsociety)”。艾略特感到好奇，但他并没有确定是否要加入这个黑客组织。机器人先生让艾略特暗中摧毁雇佣艾略特的公司。艾略特对此跨国集团反感，但秉持良心公义，他不想伤害无辜，所以仍然一次又一次抗拒去彻底揭发对世界有巨大影响力的这个集团。</p><p><img src="https://img.hacpai.com/file/2019/10/image-f0b871d7.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2019/10/image-bbcb36da.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2019/10/image-024b30b9.png" alt="image.png"></p><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p><img src="https://img.hacpai.com/file/2019/10/image-3702e045.png" alt="image.png"><br>链接: <a href="https://pan.baidu.com/s/1fCKEe5zbjmvgJuU4vC2zXg">https://pan.baidu.com/s/1fCKEe5zbjmvgJuU4vC2zXg</a> 提取码: 5ktn</p><h2 id="小福利"><a href="#小福利" class="headerlink" title="小福利"></a>小福利</h2><h3 id="王者荣耀桌面壁纸"><a href="#王者荣耀桌面壁纸" class="headerlink" title="王者荣耀桌面壁纸"></a>王者荣耀桌面壁纸</h3><p><img src="https://img.hacpai.com/file/2019/10/image-e9705985.png" alt="image.png"></p><p>有喜欢的可以下载</p><p>链接: <a href="https://pan.baidu.com/s/1FH9qG1YAf8u6ar0zUQqD6Q">https://pan.baidu.com/s/1FH9qG1YAf8u6ar0zUQqD6Q</a> 提取码: u4b9</p>]]></content>
      
      
      <categories>
          
          <category> 影视资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影视资源 </tag>
            
            <tag> 分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019最新手机号正则表达式</title>
      <link href="//articles/2019/10/11/1570793784688.html"/>
      <url>//articles/2019/10/11/1570793784688.html</url>
      
        <content type="html"><![CDATA[<h3 id="最新号段"><a href="#最新号段" class="headerlink" title="最新号段"></a>最新号段</h3><p>最新号段：</p><ul><li><p>手机号码: 13[0-9], 14[5,6,7,8,9], 15[0-3, 5-9], 16[2,5,6,7], 17[0-8], 18[0-9], 19[1,3,5,8,9]</p><ul><li>移动号段: 13[4-9],147,148,15[0-2,7-9],165,170[3,5,6],172,178,18[2-4,7-8],19[5,8]</li><li>联通号段: 130,131,132,145,146,155,156,166,167,170[4,7,8,9],171,175,176,185,186</li><li>电信号段: 133,149,153,162,170[0,1,2],173,174[0-5],177,180,181,189,19[1,3,9]</li></ul></li></ul><h3 id="手机号正则"><a href="#手机号正则" class="headerlink" title="手机号正则"></a>手机号正则</h3><ul><li>严谨</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">regex:/^1([38]\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|9[13589])\d&#123;8&#125;$/</span><br></pre></td></tr></table></figure><ul><li>简单点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^[1]([3-9])[0-9]&#123;9&#125;$/</span><br></pre></td></tr></table></figure><blockquote><p>手机号前三位<br>  130 131 132 133 134 135 136 137 138 139<br>  145 146 147 148 149<br>  150 151 152 153 | 155 156 157 158 159<br>  162 165 166 167<br>  170 171 172 173 174 175 176 177 178<br>  180 181 182 183 184 185 186 187 188 189<br>  191 193 195 198 199</p></blockquote></li></ul><h3 id="校验手机号"><a href="#校验手机号" class="headerlink" title="校验手机号"></a>校验手机号</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isMobileNO(String mobiles) &#123;</span><br><span class="line">        Pattern p = Pattern.compile(&quot;^1([38]\\d|4[5-9]|5[0-35-9]|6[2567]|7[0-8]|9[13589])\\d&#123;8&#125;$&quot;);</span><br><span class="line">        Matcher m = p.matcher(mobiles);</span><br><span class="line">        return m.matches();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正则 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> Java </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublime text 3 3207/sublime text 4 4121 破解+注册码</title>
      <link href="//articles/2019/09/26/1569491521771.html"/>
      <url>//articles/2019/09/26/1569491521771.html</url>
      
        <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="sublime-text-3-破解"><a href="#sublime-text-3-破解" class="headerlink" title="sublime text 3 破解"></a>sublime text 3 破解</h3><ol><li>安装<code>sublime text 3</code>，至于软件，<a href="http://www.sublimetext.com/3">官网下载</a></li><li>傻瓜式安装，next最后</li><li>打开<a href="https://hexed.it/">https://hexed.it/</a> 备用</li><li>打开<code>sublime text</code>的安装目录，然后备份一下<code> sublime_text.exe</code><img src="https://img.hacpai.com/file/2019/09/image-8c156def.png" alt="image.png"></li><li>在刚刚的网站上面点击<code>Open file</code> 并选择自己安装的<code>sublime_text.exe </code>可执行文件<img src="https://img.hacpai.com/file/2019/09/image-1b4c76e1.png" alt="image.png"></li><li>转到<code>Search for</code> 框, 输入<code>97 94</code> 并点击<code>Search now</code>进行搜索<img src="https://img.hacpai.com/file/2019/09/image-704209bc.png" alt="image.png"></li><li>依次点击查看搜索结果，查看是否出现<code>97 94 0D</code>，如果看到<code>97 94 0D</code>， 将它改为<code>00 00 00</code><img src="https://img.hacpai.com/file/2019/09/image-499fe3d1.png" alt="image.png"></li><li>然后点击<code>Export</code>“并保存到本地，替换源文件</li></ol><h3 id="sublime-text-4-破解"><a href="#sublime-text-4-破解" class="headerlink" title="sublime text 4 破解"></a>sublime text 4 破解</h3><p><strong>2021年7月14日 最新更新！</strong></p><p><strong>软件版本 4113 依此替换下方 2 组字节！</strong><br><code>C3 C6 01 00 C3</code> 替换为 <code>C3 C6 01 01 C3</code><br><code>51 31 C0 88 05</code> 替换为 <code>51 b0 01 88 05</code></p><p><strong>2021年12月25日 最新版本 Sublime Text 4 Build 4121&#x2F;4126，按步骤操作！</strong></p><p><strong>第一步：</strong></p><p>X64版本</p><p><code>4157415656575553B828210000</code> 替换为 <code>33C0FEC0C3575553B828210000</code></p><p>X86版本<br><code>55535756B8AC200000</code> 替换为 <code>33C0FEC0C3AC200000</code></p><p><strong>第二步：</strong><br><code>6C6963656E73652E7375626C696D6568712E636F6D</code> 替换为 <code>7375626C696D6568712E6C6F63616C686F73740000</code></p><p><strong>第三步：替换exe后用以下注册码激活</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----- BEGIN LICENSE -----</span><br><span class="line">RUYO.net</span><br><span class="line">Unlimited User License</span><br><span class="line">EA7E-81044230</span><br><span class="line">0C0CD4A8 CAA317D9 CCABD1AC 434C984C</span><br><span class="line">7E4A0B13 77893C3E DD0A5BA1 B2EB721C</span><br><span class="line">4BAAB4C4 9B96437D 14EB743E 7DB55D9C</span><br><span class="line">7CA26EE2 67C3B4EC 29B2C65A 88D90C59</span><br><span class="line">CB6CCBA5 7DE6177B C02C2826 8C9A21B0</span><br><span class="line">6AB1A5B6 20B09EA2 01C979BD 29670B19</span><br><span class="line">92DC6D90 6E365849 4AB84739 5B4C3EA1</span><br><span class="line">048CC1D0 9748ED54 CAC9D585 90CAD815</span><br><span class="line">------ END LICENSE ------</span><br></pre></td></tr></table></figure><h2 id="更改-host-文件"><a href="#更改-host-文件" class="headerlink" title="更改 host 文件"></a>更改 host 文件</h2><p><code>C:\Windows\System32\Drivers\etc</code></p><blockquote><p>添加下面两行：</p></blockquote><ul><li>127.0.0.1 license.sublimehq.com # SublimeText</li><li>127.0.0.1 <a href="http://www.sublimetext.com/">www.sublimetext.com</a>  # SublimeText</li></ul><h2 id="最后打开-sublime，输入以下许可证："><a href="#最后打开-sublime，输入以下许可证：" class="headerlink" title="最后打开 sublime，输入以下许可证："></a>最后打开 sublime，输入以下许可证：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----- BEGIN LICENSE -----</span><br><span class="line">TwitterInc</span><br><span class="line">200 User License</span><br><span class="line">EA7E-890007</span><br><span class="line">1D77F72E 390CDD93 4DCBA022 FAF60790</span><br><span class="line">61AA12C0 A37081C5 D0316412 4584D136</span><br><span class="line">94D7F7D4 95BC8C1C 527DA828 560BB037</span><br><span class="line">D1EDDD8C AE7B379F 50C9D69D B35179EF</span><br><span class="line">2FE898C4 8E4277A8 555CE714 E1FB0E43</span><br><span class="line">D5D52613 C3D12E98 BC49967F 7652EED2</span><br><span class="line">9D2D2E61 67610860 6D338B72 5CF95C69</span><br><span class="line">E36B85CC 84991F19 7575D828 470A92AB</span><br><span class="line">------ END LICENSE ------</span><br></pre></td></tr></table></figure><h2 id="收工"><a href="#收工" class="headerlink" title="收工"></a>收工</h2>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> 分享 </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python国内仓库源</title>
      <link href="//articles/2019/09/21/1569059862194.html"/>
      <url>//articles/2019/09/21/1569059862194.html</url>
      
        <content type="html"><![CDATA[<h2 id="huaji"><a href="#huaji" class="headerlink" title=":huaji:"></a>:huaji:</h2><p>今天玩了下python，发现有些库下载不下来，然后找了些国内的仓库地址：</p><ul><li><a href="https://mirrors.aliyun.com/pypi/simple/">阿里云</a>  PS：有的好像没有,今天安装<code>requests</code>库没成功，用的豆瓣的<br>  <a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></li><li><a href="https://pypi.tuna.tsinghua.edu.cn/simple/">清华大学</a>  <strong>好像挂了，反正在公司没打开</strong><br>  <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li><a href="https://pypi.doubanio.com/simple/">豆瓣(douban) </a><br>  <a href="https://pypi.doubanio.com/simple/">https://pypi.doubanio.com/simple/</a></li><li><a href="https://pypi.mirrors.ustc.edu.cn/simple/">中国科学技术大学</a>  <strong>好像挂了，反正在公司没打开</strong><br>  <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></li><li><a href="https://pypi.mirrors.ustc.edu.cn/simple/">中国科技大学</a>  <strong>好像挂了，反正在公司没打开</strong><br>  <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度网盘——电影分享</title>
      <link href="//articles/2019/09/21/1569038940574.html"/>
      <url>//articles/2019/09/21/1569038940574.html</url>
      
        <content type="html"><![CDATA[<h2 id="2019-10-12更新"><a href="#2019-10-12更新" class="headerlink" title="2019-10-12更新"></a>2019-10-12更新</h2><h3 id="玩具总动员4"><a href="#玩具总动员4" class="headerlink" title="玩具总动员4"></a>玩具总动员4</h3><p><img src="https://img.hacpai.com/file/2019/10/image-cc4990ed.png" alt="image.png"></p><h4 id="百度网盘高清资源"><a href="#百度网盘高清资源" class="headerlink" title="百度网盘高清资源"></a>百度网盘高清资源</h4><p>链接: <a href="https://pan.baidu.com/s/10AJmO-ScBeTbtT8qGVcKtQ">https://pan.baidu.com/s/10AJmO-ScBeTbtT8qGVcKtQ</a> 提取码: uphi </p><h3 id="续命之徒：绝命毒师电影"><a href="#续命之徒：绝命毒师电影" class="headerlink" title="续命之徒：绝命毒师电影"></a>续命之徒：绝命毒师电影</h3><p><img src="https://img.hacpai.com/file/2019/10/image-8da3c07b.png" alt="image.png"></p><h4 id="百度网盘高清资源-1"><a href="#百度网盘高清资源-1" class="headerlink" title="百度网盘高清资源"></a>百度网盘高清资源</h4><p>链接: <a href="https://pan.baidu.com/s/1avzPjiEF72G06jAJ0_fK4A">https://pan.baidu.com/s/1avzPjiEF72G06jAJ0_fK4A</a> 提取码: iina </p><h3 id="哪吒之魔童降世"><a href="#哪吒之魔童降世" class="headerlink" title="哪吒之魔童降世"></a>哪吒之魔童降世</h3><p><img src="https://img.hacpai.com/file/2019/09/image-acc42c0e.png" alt="image.png"></p><h4 id="高清资源"><a href="#高清资源" class="headerlink" title="高清资源"></a>高清资源</h4><p>链接: <a href="https://pan.baidu.com/s/1LrTd8d-JVbOaEOikgzWrzw">https://pan.baidu.com/s/1LrTd8d-JVbOaEOikgzWrzw</a> 提取码: hc2g </p><h3 id="速度与激情：特别行动"><a href="#速度与激情：特别行动" class="headerlink" title="速度与激情：特别行动"></a>速度与激情：特别行动</h3><p><img src="https://img.hacpai.com/file/2019/09/image-3f4324eb.png" alt="image.png"></p><h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p>链接: <a href="https://pan.baidu.com/s/12mKLNnijyaJb_iW55LN0VQ">https://pan.baidu.com/s/12mKLNnijyaJb_iW55LN0VQ</a> 提取码: irz2 </p>]]></content>
      
      
      <categories>
          
          <category> 影视资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影视资源 </tag>
            
            <tag> 分享 </tag>
            
            <tag> 福利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker删除none镜像</title>
      <link href="//articles/2019/09/19/1568896011749.html"/>
      <url>//articles/2019/09/19/1568896011749.html</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最近发现Docker的相同容器多了几个，这样就会多出好多无用的镜像，所以需要删除，查了下none镜像产生的原因：</p><blockquote><p>有时候重新构建镜像的时候，该镜像正在被某容器使用中，那么在重新构建同名同版本镜像后，docker保留原来的镜像，即容器还是用原来的，除非重启。<br>那么原来的镜像名称变成NONE，TAG也成了NONE</p></blockquote><p>看到这里就想到应该是之前的定时脚本引起的，，，</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>命令：</p><ul><li><p>列出所有的镜像</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;docker images -a</span><br></pre></td></tr></table></figure><p><img src="https://img.hacpai.com/file/2019/09/image-3593e4b9.png" alt="image.png"></p></blockquote></li><li><p>列出所有的容器</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;docker ps -a</span><br></pre></td></tr></table></figure></blockquote></li><li><p>列出所有的容器 ID</p></li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;docker ps -a -q</span><br></pre></td></tr></table></figure></blockquote><ul><li>停止所有的容器</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;docker stop $(docker ps -a -q)</span><br></pre></td></tr></table></figure></blockquote><ul><li>批量删除tag为”<none>“镜像</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;docker rmi $(docker images | grep &quot;&lt;none&gt;&quot; | awk &quot;&#123;print $3&#125;&quot;)</span><br></pre></td></tr></table></figure><p>PS:说明 </p></blockquote><ol><li><code>docker images | grep &quot;&lt;none&gt;&quot;</code>查询所有为<code>&lt;none&gt;</code>的镜像</li><li><code>awk &quot;&#123;print $3&#125;&quot;</code> 输出第三列</li></ol><ul><li>删除所有停止的容器</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure></blockquote><ul><li>查询所有的镜像的<code>IMAGE ID</code>：</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images -q</span><br></pre></td></tr></table></figure></blockquote><ul><li>删除所有的镜像：</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi $(docker images -q)</span><br></pre></td></tr></table></figure></blockquote><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> 随记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开源分享—Navicat全系产品注册激活</title>
      <link href="//articles/2019/09/11/1568201889402.html"/>
      <url>//articles/2019/09/11/1568201889402.html</url>
      
        <content type="html"><![CDATA[<h2 id="开题"><a href="#开题" class="headerlink" title="开题"></a>开题</h2><p>关于Navicat的破解激活相信使用数据库的都会使用到，前段时间换了公司，之后又是一波安装软件，然后网上找破解教程，找半天，然后下次用的时候又没有，这就很尴尬，于是想着把教程记录下来，激活软件也记录下！！！而且这次发现了 <code>GitHub</code>上面有两款开源的激活软件，这就很nice！:huaji:</p><h2 id="软件下载地址"><a href="#软件下载地址" class="headerlink" title="软件下载地址"></a>软件下载地址</h2><p>直接在Navicat的官网进行<a href="https://www.navicat.com.cn/products">下载</a><br><img src="https://img.hacpai.com/file/2019/09/image-44bfdda1.png" alt="image.png"><br>选择自己需要的产品点击【免费试用】即可下载软件！</p><h2 id="开源软件地址"><a href="#开源软件地址" class="headerlink" title="开源软件地址"></a>开源软件地址</h2><p>两种激活软件，原理应该是一样，只是操作流程不一样</p><ul><li><a href="https://github.com/DoubleLabyrinth/navicat-keygen">https://github.com/DoubleLabyrinth/navicat-keygen</a><br>参考地址：<a href="https://github.com/DoubleLabyrinth/navicat-keygen/blob/windows/README.zh-CN.md">教程</a></li><li><a href="https://github.com/Deltafox79/Navicat_Keygen">https://github.com/Deltafox79/Navicat_Keygen</a><br>参考地址:<a href="https://github.com/Deltafox79/Navicat_Keygen/releases">教程</a><br><img src="https://user-images.githubusercontent.com/2518850/64677699-60666c80-d478-11e9-97e6-6b7388016aba.jpg" alt="Navicat_Keygen_Patch_v5 2_By_DFoX"><br>基本操作：双击软件，基本不需要改变界面<ol><li>点击patch查找安装目录下面的Navicat.exe文件</li><li>直接 <code>4）</code>可以定制属于自己名称的秘钥<br><img src="https://upload-images.jianshu.io/upload_images/7213631-617c0378d9059b8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"><br><img src="https://upload-images.jianshu.io/upload_images/7213631-c25c34ee2fe8c032.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></li><li>将秘钥粘贴到软件注册页面，然后点击手动激活，复制秘钥到破解软件<br><img src="https://upload-images.jianshu.io/upload_images/7213631-a97ac52f1e96130a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"><br>4 点击左下角的 <code>Generate</code>，将新生成的 <code>code</code> copy到刚刚的软件激活页面，OK了！<br><img src="https://upload-images.jianshu.io/upload_images/7213631-c920756846df68df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp"></li></ol></li></ul><blockquote><p>PS:第一种没有界面，直接在cmd中进行操作；第二中有对应的图像，一目了然</p></blockquote><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>注意杀毒软件的屏蔽！！！！</p><p>附加：<a href="https://pan.baidu.com/s/1_q7xawvmn15BGC1oGBZhEw">百度网盘链接</a> 提取码: hwep</p><p><a href="https://pan.baidu.com/s/1kikA5lJac26m3KRHl681ug">最新破解文件</a> 提取码: v867</p>]]></content>
      
      
      <categories>
          
          <category> 开源软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分享 </tag>
            
            <tag> 福利 </tag>
            
            <tag> 开源软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十分钟搞定——Nginx安装SSL</title>
      <link href="//articles/2019/09/03/1567514885863.html"/>
      <url>//articles/2019/09/03/1567514885863.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 本文的Nginx主要是使用Docker安装，所以着重讲解容器版Nginx安装SSL过程，当然普通的Nginx安装也适用，都是通用的！</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li>安装SSL首先需要有域名，关于域名注册、备案不做讲解，网上好多教程可以自行查阅，域名的注册主要有腾讯云、阿里云、其他云</li><li>注册和备案好域名之后，我们就需要进行申请SSL证书，关于证书的申请过程不做详细介绍，腾讯云和阿里云都是有专门的文档介绍<ul><li><a href="https://cloud.tencent.com/document/product/400/8422">腾讯云SSL文档</a></li><li><a href="https://help.aliyun.com/document_detail/28554.html?spm=a2c4g.11186623.6.554.137d2179gZM50x">阿里云SSL文档</a></li></ul></li><li>下载证书<ul><li><p>腾讯云：</p><blockquote><p>直接点击下载:<br> <img src="https://img.hacpai.com/file/2019/09/image-1377912f.png" alt="image.png"><br>目录如下：<br> <img src="https://img.hacpai.com/file/2019/09/image-3d077290.png" alt="image.png"></p></blockquote></li><li><p>阿里云:(PS:没有使用阿里云 😰 )<br> <a href="https://help.aliyun.com/document_detail/98728.html?spm=a2c4g.11186623.2.19.5e092242HQlWed#concept-n45-21x-yfb">阿里云Nginx安装文档</a></p></li></ul></li></ol><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ol><li><p>首先创建文件夹备用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/nginx/logs /data/nginx/www /data/nginx/ssl /data/nginx/conf</span><br></pre></td></tr></table></figure></li><li><p>将Nginx文件夹中的两个文件上传到服务器<code>/data/nginx/ssl</code><br><img src="https://img.hacpai.com/file/2019/09/image-faea655d.png" alt="image.png"></p></li><li><p>将Nginx容器中的配置文件cp出来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp nginx:/etc/nginx/nginx.conf /data/nginx/conf/nginx.conf </span><br><span class="line"></span><br><span class="line">docker cp nginx:/etc/nginx/conf.d /data/nginx/conf/conf.d </span><br></pre></td></tr></table></figure></li><li><p>填写配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">-- 配置SSL</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">     listen 443; #SSL 访问端口号为 443</span><br><span class="line"> </span><br><span class="line">     server_name www.dome.com; #填写绑定证书的域名</span><br><span class="line"> </span><br><span class="line">     ssl on; #启用 SSL 功能</span><br><span class="line"> </span><br><span class="line">     ssl_certificate /ssl/1_www.dome.com_bundle.crt; #证书文件名称</span><br><span class="line">     ssl_certificate_key /ssl/2_www.dome.com.key; #私钥文件名称</span><br><span class="line"></span><br><span class="line">     ssl_session_timeout 5m;</span><br><span class="line">     ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #请按照这个协议配置 </span><br><span class="line">     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; #请按照这个套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">     ssl_prefer_server_ciphers on;</span><br><span class="line"> </span><br><span class="line">     #这是我的主页访问地址，因为使用的是静态的html网页，所以直接使用location就可以完成了(填写代理)</span><br><span class="line">     location / &#123;</span><br><span class="line">         root /usr/share/nginx/html; #网站主页路径。此路径仅供参考，具体请您按照实际目录操作（**自己配置**）。</span><br><span class="line">         index  index.html index.htm;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">#HTTP 自动跳转 HTTPS 的安全配置</span><br><span class="line">server&#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name www.demo.com; #填写绑定证书的域名</span><br><span class="line">  rewrite ^(.*) https://$host$1 permanent; #把http的域名请求转成https</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>PS：可以参考<a href="https://cloud.tencent.com/document/product/400/35244">腾讯云NginxSSL配置</a></p></blockquote></li><li><p>启动Nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 80:80 -p 443:443 --name nginx \</span><br><span class="line">-v /data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \</span><br><span class="line">-v /data/nginx/conf/conf.d:/etc/nginx/conf.d \</span><br><span class="line">-v /data/nginx/ssl:/ssl/ \</span><br><span class="line">-v /data/nginx/www:/usr/share/nginx/html \</span><br><span class="line">-v /data/nginx/logs:/var/log/nginx nginx</span><br></pre></td></tr></table></figure><blockquote><p>PS：<code>/data/nginx/www</code>中可自定义页面</p></blockquote></li></ol><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 魔鬼命令 </tag>
            
            <tag> 随记 </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot切面类添加接口调用耗时</title>
      <link href="//articles/2019/08/28/1566992344180.html"/>
      <url>//articles/2019/08/28/1566992344180.html</url>
      
        <content type="html"><![CDATA[<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 增加方法调用好事</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@Aspect //标注增强处理类（切面类）</span><br><span class="line">public class AdminTimeAspect &#123;</span><br><span class="line"></span><br><span class="line">    private Logger log = LoggerFactory.getLogger(AdminTimeAspect.class);</span><br><span class="line"></span><br><span class="line">    //可自定义切点位置，针对不同切点，方法上的@Around()可以这样写ex：@Around(value = &quot;methodPointcut() &amp;&amp; args(..)&quot;)</span><br><span class="line">    @Around(&quot;execution (* com.xxx.controller..*.*(..))&quot;)</span><br><span class="line">    public Object doAround(ProceedingJoinPoint joinPoint) throws Throwable&#123;</span><br><span class="line"></span><br><span class="line">        long start = System.currentTimeMillis();</span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">            Object result = joinPoint.proceed();</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            long duration = end - start;</span><br><span class="line">            log.info(&quot;【调用方法】 &quot; + joinPoint + &quot;\t【耗时】 : &quot; + (duration) + &quot; ms!&quot;);</span><br><span class="line">            return result;</span><br><span class="line"></span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            long end = System.currentTimeMillis();</span><br><span class="line">            log.info(&quot;【调用方法】 &quot; + joinPoint + &quot;\t【耗时】 : &quot; + (end - start) + &quot; ms with exception : &quot; + e.getMessage());</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS:</p><ul><li>任意公共方法的执行：execution(public * *(..))</li><li>任何一个以“set”开始的方法的执行：execution(* set*(..))</li><li>TestService 接口的任意方法的执行：execution(* com.xxx.service.TestService.*(..))</li><li>定义在service包里的任意方法的执行： execution(* com.xxx.service.<em>.</em>(..))</li><li>定义在service包和所有子包里的任意类的任意方法的执行：execution(* com.xxx.service..<em>.</em>(..))</li></ul><p><strong><code>@Around</code>的作用</strong></p><ul><li>既可以在目标方法之前织入增强动作，也可以在执行目标方法之后织入增强动作；</li><li>可以决定目标方法在什么时候执行，如何执行，甚至可以完全阻止目标目标方法的执行；</li><li>可以改变执行目标方法的参数值，也可以改变执行目标方法之后的返回值； 当需要改变目标方法的返回值时，只能使用Around方法；</li></ul><p>虽然Around功能强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturing增强方法就可以解决的事情，就没有必要使用Around增强处理了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
            <tag> 切面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux定时备份Docker的MySQL数据库</title>
      <link href="//articles/2019/08/28/1566980010076.html"/>
      <url>//articles/2019/08/28/1566980010076.html</url>
      
        <content type="html"><![CDATA[<h2 id="论备份的重要性"><a href="#论备份的重要性" class="headerlink" title="论备份的重要性"></a>论备份的重要性</h2><blockquote><p>最近遇到了好几个网友出现<code>MySQL</code>数据库勒索事件，本人前两天也遇到，事情大概这样子的：<br>    大早上起来，打开网站，发现500错误，这就很尴尬了，感觉查看日志发现怪事,数据库找不到了(PS：心里很慌，原因之前就想着备份，一直给忘了)打开数据库真的不见了，多了一个不知道的库，里面有一张WARNING表,内容全是英文(PS：额，看不懂)，去翻译，彻底惊呆了！比特币勒索（PS：心里一万个小马跑过）</p></blockquote><p><img src="https://img.hacpai.com/file/2019/08/image-5d564204.png" alt="image.png"><br><img src="https://img.hacpai.com/file/2019/08/image-6a043403.png" alt="image.png"></p><pre><code>接着百度发现在17年的时候又一波比特币勒索事件，好多数据库都被黑了，要求花钱赎回......这件事情让我认识到数据库备份的重要性，哎，赶紧重新搞一套出来，幸亏博文都有备份，哈哈...</code></pre><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><blockquote><p>由于本人使用的是<code>docker</code>部署的<code>MySQL</code>，所以去百度命令<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql mysqldump -uroot -p123456 databases &gt; /backup/data_`date +%Y%m%d%H%M%S`.sql;</span><br></pre></td></tr></table></figure><br>拿着命令去跑了下，可以备份，完美</p></blockquote><h2 id="定时备份"><a href="#定时备份" class="headerlink" title="定时备份"></a>定时备份</h2><blockquote><p>想着不能每天手动处理吧，然后就做了一个定时任务，每天备份一次，不说了，上操作：</p></blockquote><ol><li>新建脚本mysql_bak.sh，将以下命令粘贴；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># mysql 为安装mysql的docker</span><br><span class="line">#!/bin/bash</span><br><span class="line">docker_name=mysql</span><br><span class="line">data_dir=&quot;/data/backup/mysql/&quot;</span><br><span class="line">docker exec -it $docker_name mysqldump -uroot -p123456 --all-databases &gt; &quot;$data_dir/solo_`date +%Y%m%d%H%M%S`.sql&quot;</span><br><span class="line"># 删除7天以前的备份</span><br><span class="line">find $data_dir -mtime +7 -name &#x27;solo_*.sql&#x27; -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure><strong>备注</strong></li></ol><ul><li><code>docker_name</code>:<code>MySQL</code>容器名称</li><li><code>data_dir</code>:保存路径</li><li><code>--all-databases</code>:表示所有的数据库都备份，可以备份固定的数据库，直接替换就可以了</li><li><code>-mtime +7</code>: 按照文件的更改时间来查找文件，+7表示文件更改时间距现在7天以前；如果是 -mmin +7表示文件更改时间距现在7分钟以前<br>*<code>-exec rm -rf &#123;&#125; </code>;   表示执行一段shell命令，exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{}，一个空格和一个，最后是一个分号</li></ul><p>2.在定时任务中添加新的任务规则，<code>crontab -e</code>,将下面命令写入并报存:wq</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * /bin/sh /data/mysql_bak.sh &gt;&gt; /data/logs/mysql_bak.log 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">PS：/data/logs/mysql_bak.log ：输出日志</span><br></pre></td></tr></table></figure><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p><strong>学习是一种进步态度，笔记是一种成长的动作</strong></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> 魔鬼命令 </tag>
            
            <tag> 随记 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot事务</title>
      <link href="//articles/2019/08/27/1566901901979.html"/>
      <url>//articles/2019/08/27/1566901901979.html</url>
      
        <content type="html"><![CDATA[<h2 id="关于Spring-Boot启用事务："><a href="#关于Spring-Boot启用事务：" class="headerlink" title="关于Spring Boot启用事务："></a>关于<code>Spring Boot</code>启用事务：</h2><p>1.开启事务管理</p><blockquote><p>在启动类上面加事务管理注解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;@EnableTransactionManagement // 启注解事务管理，等同于xml配置方式的 &lt;tx:annotation-driven /&gt;</span><br></pre></td></tr></table></figure><p>2.事务注解详解<br>在service方法上面添加<code>@Transactional</code>注解</p></blockquote><h2 id="Transactional注解失效说明"><a href="#Transactional注解失效说明" class="headerlink" title="@Transactional注解失效说明"></a><code>@Transactional</code>注解失效说明</h2><ul><li><p>数据库引擎中<code>MyIsam</code>不支持事务，必须是<code>InnnoDB</code>引擎</p></li><li><p><code>@Transactional</code>所注解的方法只有是<code>public</code>才起作用</p></li><li><p><code>@Transactional</code>所注解的方法所在的类，必须注解<code>@Service</code>或<code>@Component</code>等</p></li><li><p>需要调用该方法，且需要支持事务特性的调用方是在 <code>@Transactional</code>所在的类的外面。注意：类内部的其他方法调用这个注解了<code>@Transactional</code>的方法，事务是不会起作用的。</p></li><li><p>@Transactional注解事务范围，并不是所有异常都可以进行数据回滚，他只有是<code>RuntimeException</code>类及其子类（中文称为：运行时异常&#x2F;<code>unchecked</code>异常&#x2F;未检异常）异常的时候才会进行数据回滚。简单的说<code>@Transactional</code>注解只有抛出<code>RuntimeException</code>类及其子类异常（中文称为：运行时异常&#x2F;unchecked异常&#x2F;未检异常）才能回滚，其他的所有异常都不行，当然出现<code>Error</code>的时候也是会回滚的</p><blockquote><p>如果希望一般的异常也能触发事务回滚，需要在注解了@Transactional的方法上，将@Transactional回滚参数设为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;@Transactional(rollbackFor=Exception.class)</span><br></pre></td></tr></table></figure><p>手动回滚事务：可以在service层方法的<code>catch </code>加 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><blockquote><p>待补充…….</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 事务Transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>修改MySQL密码</title>
      <link href="//articles/2019/08/27/1566878096384.html"/>
      <url>//articles/2019/08/27/1566878096384.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><pre><code>使用的`docker`安装`MySQL`，版本`8.0.12`</code></pre><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><ul><li>首先进入<code>docker</code>的<code>MySQL</code>容器:</li></ul><blockquote><p>使用命令<code>docker exec -it mysql /bin/bash</code></p></blockquote><ul><li>进入容器之后，登录到<code>MySQL</code>里面：</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;root@1f88cc6f4013:/# mysql -u root -p</span><br><span class="line">&gt;Enter password: </span><br></pre></td></tr></table></figure></blockquote><ul><li>输入密码之后，可以查询下目前的用户密码：</li></ul><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select host,user,authentication_string from mysql.user;</span><br></pre></td></tr></table></figure><p><img src="https://img.hacpai.com/file/2019/08/image-a2818c58.png" alt="image.png"></p></blockquote><blockquote><p>host: 允许用户登录的ip‘位置’%表示可以远程；<br>    user:当前数据库的用户名；<br>    authentication_string: 用户密码（后面有提到此字段）；</p></blockquote><p><strong>重点</strong></p><ol><li>如果当前root用户authentication_string字段下有内容，先将其设置为空，否则直接进行二步骤</li></ol><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;use mysql;</span><br><span class="line">&gt;update user set authentication_string=&#x27;&#x27; where user=&#x27;root&#x27;;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用ALTER修改root用户密码,方法为 ALTER user ‘root‘@’localhost’ IDENTIFIED BY ‘新密码’：</li></ol></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;ALTER user &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br><span class="line">&gt;ALTER user &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;</span><br></pre></td></tr></table></figure><p>修改成功，退出重启容器，重新连接就可以了</p></blockquote><p><strong>PS</strong>：<code>MySQL8.0</code>以后使用的秘钥插件是<code>caching_sha2_password</code>，以前使用的都是<code>mysql_native_password</code>，所以有可能出现<code>Navicat</code>链接失败的错误，可以使用如下命令：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 魔鬼命令 </tag>
            
            <tag> 随记 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot2.0配置Jackson日期格式输出</title>
      <link href="//articles/2019/08/23/1566533019629.html"/>
      <url>//articles/2019/08/23/1566533019629.html</url>
      
        <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><blockquote><p>今天写项目的时候发现实体对象中的字段有<code>Date</code>类型的，这样进行直接输出来的格式不是前端需要，每次都需要使用工具类进行转化，感觉很麻烦！而且在前端进行传递对应字段是<code>Date</code>类型的值得时候，也不好出来(PS:自己前端比较渣)，在测试接口的时候，使用postman发现其也是没办法传<code>Date</code>类型的参数，当然也是有传递时间戳的方式，但是测试而已没必要那么麻烦，所以就在网上查阅资料，找到了对应的<code>Jackson</code>相关配置！</p></blockquote><p><strong>SpringBoot JSON工具包默认是Jackson，只需要引入spring-boot-starter-web依赖包，自动引入相应依赖包</strong></p><h2 id="以往的方法"><a href="#以往的方法" class="headerlink" title="以往的方法"></a>以往的方法</h2><blockquote><p>之前我们都是直接进行格式化日期，然后输出才是前端需要的(图1,详情输出\图2新增参数报错)</p></blockquote><p><img src="https://img.hacpai.com/file/2019/08/image-e88be2f5.png" alt="image.png"></p><p><img src="https://img.hacpai.com/file/2019/08/image-1242c928.png" alt="image.png"></p><h2 id="Jackson时间格式介绍"><a href="#Jackson时间格式介绍" class="headerlink" title="Jackson时间格式介绍"></a>Jackson时间格式介绍</h2><blockquote><p>jackson支持的时间格式:</p></blockquote><pre><code>&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&quot;  &quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;&quot;  &quot;EEE, dd MMM yyyy HH:mm:ss zzz&quot;  &quot;yyyy-MM-dd&quot; </code></pre><blockquote><p>类型倒是挺丰富的，但就是没有常用的yyyy-MM-dd HH:mm:ss格式</p></blockquote><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li><p>1.可以直接在字段上加上注解：@JsonFormat( pattern&#x3D;”yyyy-MM-dd HH:mm:ss”)</p></li><li><p>直接在<strong>application.yml</strong>文件中添加如下配置：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">jackson: </span><br><span class="line">time-zone: GMT+8 </span><br><span class="line">date-format: yyyy-MM-dd  HH:mm:ss</span><br></pre></td></tr></table></figure><p>  上面配置对应的<strong>properties</strong>文件版本：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#jackson相关配置 </span><br><span class="line">spring.jackson.date-format = yyyy-MM-dd HH:mm:ss </span><br><span class="line">#时区必须要设置 </span><br><span class="line">spring.jackson.time-zone= GMT+8 </span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><blockquote><p>不需要使用工具类转化；</p></blockquote><p><img src="https://img.hacpai.com/file/2019/08/image-814340da.png" alt="image.png"></p><p><img src="https://img.hacpai.com/file/2019/08/image-bc4aadfd.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> Jackson </tag>
            
            <tag> 日期输出 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot启动自定义Banner</title>
      <link href="//articles/2019/08/20/1566281280069.html"/>
      <url>//articles/2019/08/20/1566281280069.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天启动项目的时候注意到Spring Boot的启动日志图案，感觉不太好看，想到之前浏览过一篇文章<a href="http://blog.didispace.com/spring-boot-banner/"># 新年彩蛋：Spring Boot自定义Banner</a>，介绍了Spring Boot启动Banner可以使用自定义图案，学习下，随手记录在此：</p></blockquote><h2 id="Spring-Boot-正常启动效果"><a href="#Spring-Boot-正常启动效果" class="headerlink" title="Spring Boot 正常启动效果"></a>Spring Boot 正常启动效果</h2><p><img src="https://img.hacpai.com/file/2019/08/image-63b7fe98.png" alt="image.png"></p><p>上图就是Spring Boot 正常启动<code>Banner</code>的效果</p><pre><code>`Banner`是`SpringBoot`框架一个特色的部分，其设计的目的无非就是一个框架的标识，其中包含了版本号、框架名称等内容，既然`SpringBoot`为我们提供了这个模块，它肯定也是可以更换的这也是`Spring`开源框架的设计理念。</code></pre><h2 id="更换Banner效果"><a href="#更换Banner效果" class="headerlink" title="更换Banner效果"></a>更换Banner效果</h2><p><img src="https://img.hacpai.com/file/2019/08/image-960a70e1.png" alt="image.png"></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><pre><code>简单创建一个`SpringBoot`框架：在Spring Boot工程的`/src/main/resources`目录下创建一个`banner.txt`文件，然后将ASCII字符画复制进去，就能替换默认的banner了，比如上图中的输出，就采用了下面的`banner.txt`内容：</code></pre><p>永不宕机佛祖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_YELLOW&#125;</span><br><span class="line">////////////////////////////////////////////////////////////////////</span><br><span class="line">//                                                                //</span><br><span class="line">//                          $&#123;AnsiColor.BRIGHT_RED&#125;_ooOoo_$&#123;AnsiColor.BRIGHT_YELLOW&#125;                               //</span><br><span class="line">//                         $&#123;AnsiColor.BRIGHT_RED&#125;o8888888o$&#123;AnsiColor.BRIGHT_YELLOW&#125;                              //</span><br><span class="line">//                         $&#123;AnsiColor.BRIGHT_RED&#125;88$&#123;AnsiColor.BRIGHT_YELLOW&#125;&quot; . &quot;$&#123;AnsiColor.BRIGHT_RED&#125;88$&#123;AnsiColor.BRIGHT_YELLOW&#125;                              //</span><br><span class="line">//                         (| ^_^ |)                              //</span><br><span class="line">//                         O\  =  /O                              //</span><br><span class="line">//                      ____/`---&#x27;\____                           //</span><br><span class="line">//                    .&#x27;  \\|     |//  `.                         //</span><br><span class="line">//                   /  \\|||  :  |||//  \                        //</span><br><span class="line">//                  /  _||||| -:- |||||-  \                       //</span><br><span class="line">//                  |   | \\\  -  /// |   |                       //</span><br><span class="line">//                  | \_|  &#x27;&#x27;\---/&#x27;&#x27;  |   |                       //</span><br><span class="line">//                  \  .-\__  `-`  ___/-. /                       //</span><br><span class="line">//                ___`. .&#x27;  /--.--\  `. . ___                     //</span><br><span class="line">//              .&quot;&quot; &#x27;&lt;  `.___\_&lt;|&gt;_/___.&#x27;  &gt;&#x27;&quot;&quot;.                  //</span><br><span class="line">//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //</span><br><span class="line">//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //</span><br><span class="line">//      ========`-.____`-.___\_____/___.-`____.-&#x27;========         //</span><br><span class="line">//                           `=---=&#x27;                              //</span><br><span class="line">//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //</span><br><span class="line">//            佛祖保佑       永不宕机     永无BUG                 //</span><br><span class="line">////////////////////////////////////////////////////////////////////</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;</span><br><span class="line">Application Version: $&#123;application.version&#125;$&#123;application.formatted-version&#125;</span><br><span class="line">Spring Boot Version: $&#123;spring-boot.version&#125;$&#123;spring-boot.formatted-version&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的内容中可以看到，还使用了一些属性设置：</p><ul><li><code>$&#123;AnsiColor.BRIGHT_RED&#125;</code>：设置控制台中输出内容的颜色</li><li><code>$&#123;application.version&#125;</code>：用来获取<code>MANIFEST.MF</code>文件中的版本号</li><li><code>$&#123;application.formatted-version&#125;</code>：格式化后的<code>$&#123;application.version&#125;</code>版本信息</li><li><code>$&#123;spring-boot.version&#125;</code>：Spring Boot的版本号</li><li><code>$&#123;spring-boot.formatted-version&#125;</code>：格式化后的<code>$&#123;spring-boot.version&#125;</code>版本信息</li></ul><h2 id="生成工具"><a href="#生成工具" class="headerlink" title="生成工具"></a>生成工具</h2><p>如果让我们手工的来编辑这些字符画，显然是一件非常困难的差事。所以，我们可以借助下面这些工具，轻松地根据文字或图片来生成用于Banner输出的字符画。</p><ul><li><a href="http://patorjk.com/software/taag">http://patorjk.com/software/taag</a></li><li><a href="http://www.network-science.de/ascii/">http://www.network-science.de/ascii/</a></li><li><a href="http://www.degraeve.com/img2txt.php">http://www.degraeve.com/img2txt.php</a></li><li><a href="http://www.makepic.net/tool/image2ascii.html">http://www.makepic.net/tool/image2ascii.html</a> : <strong>该网站可以将图片转成字符</strong></li></ul><h2 id="有趣的图案"><a href="#有趣的图案" class="headerlink" title="有趣的图案"></a>有趣的图案</h2><p><img src="https://img.hacpai.com/file/2019/08/image-31ab8941.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;                      !                      天地山青   $&#123;AnsiColor.BRIGHT_YELLOW&#125;                      !</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;                     /^\                        $&#123;AnsiColor.BRIGHT_YELLOW&#125;道法无常                     /^\</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;                   /     \                   天地无极   $&#123;AnsiColor.BRIGHT_YELLOW&#125;                   /     \</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;   |            | (       ) |            |      $&#123;AnsiColor.BRIGHT_YELLOW&#125;乾坤戒法   |            | (       ) |            |</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;  /^\  |       /^\ \     / /^\       |  /^\  元阳入体   $&#123;AnsiColor.BRIGHT_YELLOW&#125;  /^\  |       /^\ \     / /^\       |  /^\</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;  |O| /^\     (   )|-----|(   )     /^\ |O|     $&#123;AnsiColor.BRIGHT_YELLOW&#125;五毒不侵  |O| /^\     (   )|-----|(   )     /^\ |O|</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;  |_| |-| |^-^|---||-----||---|^-^| |-| |_|  九阳之体   $&#123;AnsiColor.BRIGHT_YELLOW&#125;  |_| |-| |^-^|---||-----||---|^-^| |-| |_|</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;  |O| |O| |/^\|/^\||  |  ||/^\|/^\| |O| |O|     $&#123;AnsiColor.BRIGHT_YELLOW&#125;化缘神功  |O| |O| |/^\|/^\||  |  ||/^\|/^\| |O| |O|</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;  |-| |-| ||_|||_||| /^\ |||_|||_|| |-| |-|  邪魔退散   $&#123;AnsiColor.BRIGHT_YELLOW&#125;  |-| |-| ||_|||_||| /^\ |||_|||_|| |-| |-|</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;  |O| |O| |/^\|/^\||(   )||/^\|/^\| |O| |O|     $&#123;AnsiColor.BRIGHT_YELLOW&#125;永不宕机  |O| |O| |/^\|/^\||(   )||/^\|/^\| |O| |O|</span><br><span class="line">$&#123;AnsiColor.BRIGHT_RED&#125;  |-| |-| ||_|||_||||   ||||_|||_|| |-| |-|  永无八哥   $&#123;AnsiColor.BRIGHT_YELLOW&#125;  |-| |-| ||_|||_||||   ||||_|||_|| |-| |-|</span><br><span class="line">$&#123;AnsiColor.BRIGHT_CYAN&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img.hacpai.com/file/2019/08/image-f16722bb.png" alt="image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$&#123;AnsiColor.BRIGHT_YELLOW&#125;</span><br><span class="line">                       d*##$.</span><br><span class="line"> zP&quot;&quot;&quot;&quot;&quot;$e.           $&quot;    $o</span><br><span class="line">4$       &#x27;$          $&quot;      $</span><br><span class="line">&#x27;$        &#x27;$        J$       $F</span><br><span class="line"> &#x27;b        $k       $&gt;       $</span><br><span class="line">  $K        $r     J$       d$</span><br><span class="line">  &#x27;$         $     $&quot;       $~</span><br><span class="line">   &#x27;$        &quot;$   &#x27;$E       $</span><br><span class="line">    $         $L   $&quot;      $F ...</span><br><span class="line">     $.       4B   $      $$$*&quot;&quot;&quot;*b</span><br><span class="line">     &#x27;$        $.  $$     $$      $F</span><br><span class="line">      &quot;$       RS  $F     $&quot;      $</span><br><span class="line">       $k      ?$ u*     dF      .$</span><br><span class="line">       ^$.      $$&quot;     z$      u$$$$e</span><br><span class="line">        #Sb             $E.dW@e$&quot;    ?$</span><br><span class="line">         #$           .o$$# d$$$$c    ?F</span><br><span class="line">          $      .d$$#&quot; . zo$&gt;   #$r .uF</span><br><span class="line">          $L .u$*&quot;      $&amp;$$$k   .$$d$$F</span><br><span class="line">           $$&quot;            &quot;&quot;^&quot;$$$P&quot;$P9$</span><br><span class="line">          JP              .o$$$$u:$P $$</span><br><span class="line">          $          ..ue$&quot;      &quot;&quot;  $&quot;</span><br><span class="line">         d$          $F              $</span><br><span class="line">         $$      ...udE             4B</span><br><span class="line">          #$     &quot;&quot;&quot;` $r            @$</span><br><span class="line">           ^$L        &#x27;$            $F</span><br><span class="line">             RN        4N           $</span><br><span class="line">              *Sb                  d$</span><br><span class="line">               $$k                 $F</span><br><span class="line">                $$b                $F</span><br><span class="line">                 $&quot;&quot;               $F</span><br><span class="line">                 &#x27;$                $</span><br><span class="line">                  $L               $</span><br><span class="line">                  &#x27;$               $</span><br><span class="line">                   $               $</span><br><span class="line">                   </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> SpringBoot </tag>
            
            <tag> 趣味编程 </tag>
            
            <tag> Banner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Spring Boot跨域解决</title>
      <link href="//articles/2019/08/14/1565775617177.html"/>
      <url>//articles/2019/08/14/1565775617177.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在项目开发中，不可避免会遇到跨域问题！本文简述下遇到跨域解决办法：</p></blockquote><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>首先，我们需要了解一下一个URL是怎么组成的：</p><blockquote><p>&#x2F;&#x2F; 协议 + 域名（子域名 + 主域名） + 端口号 + 资源地址</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http: + // + www.baidu.com + :8080/</span><br></pre></td></tr></table></figure><p>只要<strong>协议，子域名，主域名，端口号</strong>这四项组成部分中有一项不同，就可以认为是不同的域，不同的域之间互相访问资源，就被称之为跨域。</p><pre><code>    随着前后端分离开发的越来越普及，会经常遇到跨域的问题，比如用ajax从`http://localhost:8080/test.html`页面向后台接口`http://localhost:8888/user/list`发起请求，由于两个url端口不同，所以属于跨域，在console打印台会报No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</code></pre><h3 id="解决跨域的几种方案"><a href="#解决跨域的几种方案" class="headerlink" title="解决跨域的几种方案"></a>解决跨域的几种方案</h3><h4 id="方法一：JSONP"><a href="#方法一：JSONP" class="headerlink" title="方法一：JSONP"></a>方法一：JSONP</h4><pre><code>前端使用ajax，将dataType设置成jsonp，这里不做太多说明！</code></pre><blockquote><p>重点通过 <strong>跨域访问技术CORS Cross-Origin Resource Sharing</strong>来解决的，具体的实现原理不做深入的探究，目的是解决跨域问题~</p></blockquote><h4 id="方法二：注解"><a href="#方法二：注解" class="headerlink" title="方法二：注解"></a>方法二：注解</h4><p>在Spring Boot 中给我们提供了一个注解<code>@CrossOrigin</code>来实现跨域，这个注解可以实现方法级别的细粒度的跨域控制。我们可以在类或者方法上添加该注解，如果在类上添加该注解，该类下的所有接口都可以通过跨域访问，如果在方法上添加注解，那么仅仅只限于加注解的方法可以访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/user&quot;)</span><br><span class="line">@CrossOrigin</span><br><span class="line">public class UserController &#123;</span><br><span class="line">   @Autowired</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">   @RequestMapping(&quot;/findAll&quot;)</span><br><span class="line">    public Object findAll()&#123;</span><br><span class="line">        return userService.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法三：实现WebMvcConfigurer"><a href="#方法三：实现WebMvcConfigurer" class="headerlink" title="方法三：实现WebMvcConfigurer"></a>方法三：实现WebMvcConfigurer</h4><p>这里可以通过实现<code>WebMvcConfigurer</code>接口中的<code>addCorsMappings()</code>方法来实现跨域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">class CORSConfiguration implements WebMvcConfigurer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addCorsMappings(CorsRegistry registry) &#123;</span><br><span class="line">        registry.addMapping(&quot;/**&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法四：Filter"><a href="#方法四：Filter" class="headerlink" title="方法四：Filter"></a>方法四：Filter</h4><p>我们可以通过实现Fiter接口在请求中添加一些Header来解决跨域的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CORSFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">            throws IOException, ServletException &#123;</span><br><span class="line">        HttpServletResponse res = (HttpServletResponse) response;</span><br><span class="line">        res.addHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</span><br><span class="line">        res.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line">        res.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, DELETE, PUT&quot;);</span><br><span class="line">        res.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-CAF-Authorization-Token,sessionToken,X-TOKEN&quot;);</span><br><span class="line">        if (((HttpServletRequest) request).getMethod().equals(&quot;OPTIONS&quot;)) &#123;</span><br><span class="line">            response.getWriter().println(&quot;ok&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Nginx配置解决跨域问题"><a href="#Nginx配置解决跨域问题" class="headerlink" title="Nginx配置解决跨域问题"></a>Nginx配置解决跨域问题</h4><p>如果我们在项目中使用了Nginx，可以在Nginx中添加以下的配置来解决跨域（原理其实和Filter类似，只不过把活儿丢给了运维🤔）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">   add_header Access-Control-Allow-Origin *;</span><br><span class="line">   add_header Access-Control-Allow-Headers X-Requested-With;</span><br><span class="line">   add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;</span><br><span class="line"></span><br><span class="line">   if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">     return 204;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Spring </tag>
            
            <tag> CORS跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>页脚增加网站运行时间统计</title>
      <link href="//articles/2019/08/13/1565684501665.html"/>
      <url>//articles/2019/08/13/1565684501665.html</url>
      
        <content type="html"><![CDATA[<hr><p>关于网站页脚展示网站的运行时间问题：</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p>直接将下面代码粘贴在页脚就行(Solo管理)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;sitetime&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;script language=javascript&gt;</span><br><span class="line">function siteTime()&#123;</span><br><span class="line">window.setTimeout(&quot;siteTime()&quot;, 1000);</span><br><span class="line">var seconds = 1000;</span><br><span class="line">var minutes = seconds * 60;</span><br><span class="line">var hours = minutes * 60;</span><br><span class="line">var days = hours * 24;</span><br><span class="line">var years = days * 365;</span><br><span class="line">var today = new Date();</span><br><span class="line">var todayYear = today.getFullYear();</span><br><span class="line">var todayMonth = today.getMonth()+1;</span><br><span class="line">var todayDate = today.getDate();</span><br><span class="line">var todayHour = today.getHours();</span><br><span class="line">var todayMinute = today.getMinutes();</span><br><span class="line">var todaySecond = today.getSeconds();</span><br><span class="line">/* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)</span><br><span class="line">year - 作为date对象的年份，为4位年份值</span><br><span class="line">month - 0-11之间的整数，做为date对象的月份</span><br><span class="line">day - 1-31之间的整数，做为date对象的天数</span><br><span class="line">hours - 0(午夜24点)-23之间的整数，做为date对象的小时数</span><br><span class="line">minutes - 0-59之间的整数，做为date对象的分钟数</span><br><span class="line">seconds - 0-59之间的整数，做为date对象的秒数</span><br><span class="line">microseconds - 0-999之间的整数，做为date对象的毫秒数 */</span><br><span class="line">var t1 = Date.UTC(2019,08,01,15,00,00); //北京时间2019-08-01 00:00:00</span><br><span class="line">var t2 = Date.UTC(todayYear,todayMonth,todayDate,todayHour,todayMinute,todaySecond);</span><br><span class="line">var diff = t2-t1;</span><br><span class="line">var diffYears = Math.floor(diff/years);</span><br><span class="line">var diffDays = Math.floor((diff/days)-diffYears*365);</span><br><span class="line">var diffHours = Math.floor((diff-(diffYears*365+diffDays)*days)/hours);</span><br><span class="line">var diffMinutes = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours)/minutes);</span><br><span class="line">var diffSeconds = Math.floor((diff-(diffYears*365+diffDays)*days-diffHours*hours-diffMinutes*minutes)/seconds);</span><br><span class="line">document.getElementById(&quot;sitetime&quot;).innerHTML=&quot; 已运行&quot;+/*diffYears+&quot; 年 &quot;+*/diffDays+&quot; 天 &quot;+diffHours+&quot; 小时 &quot;+diffMinutes+&quot; 分钟 &quot;+diffSeconds+&quot; 秒&quot;;</span><br><span class="line">&#125;/*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/</span><br><span class="line">siteTime();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="更新保存即可"><a href="#更新保存即可" class="headerlink" title="更新保存即可"></a>更新保存即可</h2><p><img src="https://img.hacpai.com/file/2019/08/image-f84e68b1.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随记 </tag>
            
            <tag> Solo </tag>
            
            <tag> 网站 </tag>
            
            <tag> 页脚 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux的定时任务crontab执行失败(报错No such file or directory)</title>
      <link href="//articles/2019/08/13/1565669241375.html"/>
      <url>//articles/2019/08/13/1565669241375.html</url>
      
        <content type="html"><![CDATA[<ol><li><p><strong>crond服务未启动</strong></p><p> crontab不是Linux内核的功能，而是依赖一个crond服务，这个服务可以启动当然也可以停止。如果停止了就无法执行任何定时任务了，解决的方法是打开它:</p><blockquote><p>service crond start</p></blockquote><p> 如果提示crond命令不存在，可能被误删除了，CentOS下可以通过这个命令重新安装： </p><blockquote><p>yum -y install crontabs</p></blockquote></li><li><p><strong>权限问题</strong><br> 比如：脚本没有x执行权限，解决方法：</p><blockquote><p>增加执行权限，或者用bash abc.sh的方法执行（chmod 744 test.sh）</p></blockquote><ul><li>关于权限</li></ul><p> Linux系统中，每个用户的角色和权限划分的很细致也很严格，每个文件（目录）都设有访问许可权限，利用这种机制来决定某个用户通过某种方式对文件（目录）进行读、写、执行等操作。</p><p> 操作文件或目录的用户，有3种不同类型：<strong>文件所有者、群组用户、其他用户</strong>。<strong>最高位表示文件所有者的权限值，中间位表示群组用户的权限值，最低位则表示其他用户的权限值</strong>，所以，chmod 777中，三个数字7分别对应上面三种用户，权限值都为7。</p><p> 文件或目录的权限又分为3种：只读、只写、可执行。</p><table><thead><tr><th>权限</th><th>权限数值</th><th>二进制</th><th>具体作用</th></tr></thead><tbody><tr><td>r</td><td>4</td><td>00000100</td><td>read，读取。当前用户可以读取文件内容，当前用户可以浏览目录。</td></tr><tr><td>w</td><td>2</td><td>00000010</td><td>write，写入。当前用户可以新增或修改文件内容，当前用户可以删除、移动目录或目录内文件。</td></tr><tr><td>x</td><td>1</td><td>00000001</td><td>execute，执行。当前用户可以执行文件，当前用户可以进入目录。</td></tr></tbody></table><p> 依照上面的表格，权限组合就是对应权限值求和，如下：</p><p> 7 &#x3D; 4 + 2 + 1      读写运行权限<br> 5 &#x3D; 4 + 1             读和运行权限</p><p> 4 &#x3D; 4                   只读权限</p><p> 因此，大家也就明白了  <em>chmod  744  filename</em>  命令的含义了。</p></li><li><p><strong>路径问题</strong></p><p> 有的命令在shell中执行正常，但是在crontab执行却总是失败。有可能是因为crontab使用的sh未正确识别路径，比如：<br> 以root身份登录shell后执行一个&#x2F;data&#x2F;test.sh，进入到data目录，只要执行<code> ./test.sh</code>就可以了。<br> 但是在crontab中，就会找不到这个脚本，必须写完整：<code>/data/test.sh</code></p></li><li><p><strong>时差问题</strong><br> 因为服务器与客户端时差问题，所以crontab的时间以服务器时间为准。</p></li><li><p><strong>变量问题</strong><br> 有时候命令中含有变量，但crontab执行时却没有，也会造成执行失败。<br> crontab默认是不加载变量的，不要假定cron知道所需要的特殊环境，它其实并不知道。<br> 所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量</p><ul><li>在.sh脚本里面配置变量 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat test.sh  </span><br><span class="line">#!/bin/sh  </span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></li><li>在定时任务执行的时候说明变量(本人的方法)，**&#x2F;bin&#x2F;sh** 如下：<br> <code>* 3 * * * /bin/sh /data/test.sh &gt;&gt; /data/test.log 2&gt;&amp;1</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Crontab </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
